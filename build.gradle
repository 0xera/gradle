import java.text.SimpleDateFormat
import java.util.jar.Attributes
import org.apache.tools.ant.taskdefs.condition.Os
import org.gradle.api.artifacts.repositories.WebdavResolver
import org.gradle.api.tasks.testing.ForkMode
import org.gradle.api.tasks.wrapper.Wrapper
import org.gradle.build.release.Svn
import org.gradle.build.release.Version
import org.gradle.build.samples.WrapperProjectCreator
import org.gradle.build.startscripts.StartScriptsGenerator
import org.apache.ivy.plugins.resolver.*

/**
 * For building Gradle you usually don't need to specify any properties. Only certain functionality of the Gradle requires
 * setting certain properties. Those properties can be set in the gradle.properties file in the the gradle user home. The
 * following properties can be set:
 *
 * Uploading distributions to Gradle's release and snapshot repository at codehaus: codehausUserName, codehausUserPassword
 * Uploading the userguide and the javadoc to Gradle's website: websiteFtpUserName, websiteFtpUserPassword
 * Using the build to create a new distribution and install it on the local machine: gradle_installPath
 * Creating a JDK-1.4 compatible distribution with retro-translator: gradle_retroLibsDir (This dir should contain rt.jar, jce.jar and jsse.jar from
 * a JDK 1.4).
 */

defaultTasks "clean", "dists"

usePlugin BasePlugin

svn = new Svn(project)

type = 'jar'

buildTime = new Date()
versionModifier = null

startScriptsDir = new File("$buildDir/startScripts")
distLibsDir = new File("$buildDir/distLibs")

archivesBaseName = 'gradle'

libraries = [
        ant             : 'org.apache.ant:ant:1.7.0@jar',
        ant_junit       : 'org.apache.ant:ant-junit:1.7.0@jar',
        ant_launcher    : 'org.apache.ant:ant-launcher:1.7.0@jar',
        antlr           : 'antlr:antlr:2.7.7@jar',
        asm_all         : 'asm:asm-all:2.2.3@jar',
        commons_cli     : 'commons-cli:commons-cli:1.2@jar',
        commons_io      : 'commons-io:commons-io:1.4@jar',
        dom4j           : 'dom4j:dom4j:1.6.1@jar',
        groovy          : 'org.codehaus.groovy:groovy:1.6.4@jar',
        jaxen           : 'jaxen:jaxen:1.1@jar',
        jopt_simple     : 'net.sf.jopt-simple:jopt-simple:2.4.1@jar',
        jul_to_slf4j    : 'org.slf4j:jul-to-slf4j:1.5.8@jar',
        logback_classic : 'ch.qos.logback:logback-classic:0.9.17@jar',
        logback_core    : 'ch.qos.logback:logback-core:0.9.17@jar',
        slf4j_api       : 'org.slf4j:slf4j-api:1.5.8@jar',
        junit           : 'junit:junit:4.7'
    ]

libraries.groovy_depends  = [libraries.groovy, libraries.ant, libraries.ant_launcher, libraries.asm_all,
        libraries.antlr, libraries.commons_cli, libraries.ant_junit]

allprojects {
    group = 'org.gradle'

    plugins.withType(JavaPlugin).whenPluginAdded {
        sourceCompatibility = 1.5
        targetCompatibility = 1.5
    }

    repositories {
        mavenCentral()
        add(new URLResolver()) {
            name = 'sf_gradleRepo'
            addArtifactPattern('http://gradle.sourceforge.net/gradleRepo/[organisation]/[module](/[branch])/[type]s/[artifact]-[revision](-[classifier])(.[ext])')
        }
    }

    version = new Version(svn, project, false)
}

def FIRST_LEVEL_JMOCK = ['org.hamcrest:hamcrest-core:1.1@jar', 'org.hamcrest:hamcrest-library:1.1@jar', 'org.jmock:jmock-junit4:2.5.1@jar']
configure(groovyProjects()) {

    usePlugin 'groovy'
    usePlugin 'code-quality'

    archivesBaseName = "gradle-${name.replaceAll("\\p{Upper}") { "-${it.toLowerCase()}" } }"
    dependencies {
        testCompile libraries.junit, FIRST_LEVEL_JMOCK
        testCompile module("org.jmock:jmock:2.5.1") {
            dependencies('org.jmock:jmock-legacy:2.5.1@jar', 'org.objenesis:objenesis:1.0', 'cglib:cglib-nodep:2.1_3')
            dependencies(FIRST_LEVEL_JMOCK as Object[])
        }
        // todo - these should not be here
        testCompile 'org.jmock:jmock-legacy:2.5.1@jar', 'org.objenesis:objenesis:1.0', 'cglib:cglib-nodep:2.1_3'
    }

    checkstyleConfigDir = "$rootDir/config/checkstyle"
    checkstyleConfigFileName = new File(checkstyleConfigDir, "checkstyle.xml")
    codeNarcConfigFileName = "$rootDir/config/codenarc.xml"
    [checkstyleMain, checkstyleTest].each { it.properties.checkstyleConfigDir = checkstyleConfigDir }
}

project(':docs') {
    docsDir = file("$buildDir/docs")
    samplesDir = file("$buildDir/samples")
    distDocsDir = file("$buildDir/distDocs")
    docbookSrc = new File(project.buildDir, 'docbook/src')
    samplesSrcDir = file('src/samples')
}

allprojects {
    task ide << {task ->
        def config = task.project.configurations.findByName('testRuntime')
        if (!config) {
            return
        }
        def libDir = task.project.file('lib')
        ant.delete(dir: libDir)
        copy {
            from config.copyRecursive(DependencySpecs.type(Type.EXTERNAL)).files
            into libDir
        }
    }
}

configurations {
    dists
    distLib {
        visible = false
    }
    retrotranslatorAntTask
}

dependencies {
    distLib project(':wrapper'), project(':core'), project(':ui'), project(':openApi')

    retrotranslatorAntTask 'net.sf.retrotranslator:retrotranslator-runtime:1.2.7@jar', 'net.sf.retrotranslator:retrotranslator-transformer:1.2.7@jar',
            'backport-util-concurrent:backport-util-concurrent:3.1@jar'
}

clean.dependsOn subprojects.collect { "$it.path:clean" }

task check(overwrite: true, dependsOn: groovyProjects()*.check)
task test(overwrite: true, dependsOn: groovyProjects()*.test)

distributionUploadUrl = null
docsRemoteDir = ''
javadocRemoteDir = ''
groovydocRemoteDir = ''
gradle.taskGraph.whenReady {graph ->
    String prefix = ''
    if (graph.hasTask(':release')) {
        versionModifier = ''
        distributionUploadUrl = 'https://dav.codehaus.org/dist/gradle'
        prefix = version as String
    } else {
        versionModifier = new SimpleDateFormat('yyyyMMddHHmmssZ').format(buildTime)
        distributionUploadUrl = 'https://dav.codehaus.org/snapshots.dist/gradle'
        prefix = 'latest'
    }
    docsRemoteDir = prefix + '/docs'
    javadocRemoteDir = docsRemoteDir + '/javadoc'
    groovydocRemoteDir = docsRemoteDir + '/groovydoc'
    configure(groovyProjects()) {
      jar.manifest.mainAttributes([
              (Attributes.Name.IMPLEMENTATION_TITLE.toString()): 'Gradle',
              (Attributes.Name.IMPLEMENTATION_VERSION.toString()): version.toString(),
      ])
    }
}

task startScripts << {
    ant.mkdir(dir: startScriptsDir)
    StartScriptsGenerator.generate(project(':core').jar.archiveName, startScriptsDir, archivesBaseName)    
}

task distLibs(dependsOn: configurations.distLib) << {
    removeAnyExistingOldGradleLibs()
    copy {
        from configurations.distLib
        into distLibsDir
    }
}

def removeAnyExistingOldGradleLibs() {
    if (distLibsDir.exists()) ant.delete { fileset(dir: distLibsDir, includes: "$archivesBaseName-*.jar") }
}

zipRootFolder = "$archivesBaseName-${-> version}"

task allZip(type: Zip, dependsOn: [startScripts, distLibs, 'docs:docs']) {
    classifier = 'all'
    zipFileSet(dir: startScriptsDir, prefix: "$zipRootFolder/bin", fileMode: '775')
    zipFileSet(dir: 'src/toplevel', prefix: zipRootFolder)
    groovyProjects().each { project ->
        project.sourceSets.main.java.srcDirs.each { zipFileSet(dir: it, prefix: "$zipRootFolder/src") }
        project.sourceSets.main.resources.srcDirs.each { zipFileSet(dir: it, prefix: "$zipRootFolder/src") }
        project.sourceSets.main.groovy.srcDirs.each { zipFileSet(dir: it, prefix: "$zipRootFolder/src") }
    }
    zipFileSet(dir: distLibsDir, prefix: "$zipRootFolder/lib")
    zipFileSet(dir: project(':docs').distDocsDir, prefix: zipRootFolder)
    zipFileSet(dir: project(':docs').docsDir, prefix: "$zipRootFolder/docs")
    zipFileSet(dir: project(':docs').samplesDir, prefix: "$zipRootFolder/samples")
}

task binZip(type: Zip, dependsOn: [startScripts, distLibs, 'docs:distDocs']) {
    classifier = 'bin'
    zipFileSet(dir: startScriptsDir, prefix: "$zipRootFolder/bin", fileMode: '775')
    zipFileSet(dir: 'src/toplevel', prefix: zipRootFolder)
    zipFileSet(dir: distLibsDir, prefix: "$zipRootFolder/lib")
    zipFileSet(dir: project(':docs').distDocsDir, prefix: zipRootFolder)
}

task srcZip(type: Zip) {
    classifier = 'src'
    zipFileSet(dir: projectDir, prefix: zipRootFolder, fileMode: '775') {
        include 'gradlew'
    }
    zipFileSet(dir: projectDir, prefix: zipRootFolder) {
        ['buildSrc', 'subprojects/*'].each {
            include "$it/*.gradle"
            include "$it/src/"
        }
        include 'config/'
        include 'src/'
        include '*.gradle'
        include 'gradle.properties'
        include 'wrapper/'
        include 'gradlew.bat'
    }
}

distsRetroLibsFolder = new File(distsDir, 'retroLibs')

task retroTranslateLibs(dependsOn: distLibs) << {
    distsRetroLibsFolder.mkdirs()
    ant {
        taskdef(name: "retrotranslator", classname: "net.sf.retrotranslator.transformer.RetrotranslatorTask",
                classpath: configurations.retrotranslatorAntTask.asPath)
        List libFiles = distLibsDir.listFiles()
        File logbackCore = libFiles.find { it.name.startsWith('logback-core') }
        File logbackClassic = libFiles.find { it.name.startsWith('logback-classic') }
        File gradle = libFiles.find { it.name.startsWith('gradle-') && !it.name.startsWith('gradle-wrapper') }
        File gradleWrapper = libFiles.find { it.name.startsWith('gradle-wrapper')}
        List retroFiles = [logbackCore, logbackClassic, gradle, gradleWrapper]
        String libExcludes = retroFiles.join(',')
        retroFiles.each {File file ->
            retroExe(file) {
                fileset(dir: distsRetroLibsFolder)
                fileset(dir: distLibsDir, excludes: libExcludes)
                fileset(dir: gradle_retroLibsDir)
            }
        }
    }
}
retroTranslateLibs.enabled = project.hasProperty('gradle_retroLibsDir')

void retroExe(File file, Closure fileSet) {
    ant {
        retrotranslator(target: "1.4", destjar: new File(distsRetroLibsFolder, file.name), smart: true, verify: false, failonwarning: false) {
            jarfileset(dir: distLibsDir, includes: file.name)
            classpath() {
                fileset(dir: gradle_retroLibsDir)
                fileSet.delegate = delegate
                fileSet()
            }
        }
    }
}

task jdk14AllZip(type: Zip, dependsOn: [retroTranslateLibs, startScripts]) {
    classifier = 'all-jdk14'
    zipFileSet(dir: distLibsDir, prefix: "$zipRootFolder/lib") {
        exclude 'gradle*.jar'
        exclude 'logback*.jar'
    }
    zipFileSet(dir: distsRetroLibsFolder, prefix: "$zipRootFolder/lib")
    configurations.retrotranslatorAntTask.each {File file ->
        zipFileSet(dir: file.parentFile, prefix: "$zipRootFolder/lib") {
            include file.name
        }
    }
    zipFileSet(dir: startScriptsDir, prefix: "$zipRootFolder/bin", fileMode: '775')
    zipFileSet(dir: 'src/toplevel', prefix: zipRootFolder)
    groovyProjects().each { project ->
        project.sourceSets.main.java.srcDirs.each { zipFileSet(dir: it, prefix: "$zipRootFolder/src") }
        project.sourceSets.main.resources.srcDirs.each { zipFileSet(dir: it, prefix: "$zipRootFolder/src") }
        project.sourceSets.main.groovy.srcDirs.each { zipFileSet(dir: it, prefix: "$zipRootFolder/src") }
    }
    zipFileSet(dir: project(':docs').distDocsDir, prefix: zipRootFolder)
    zipFileSet(dir: project(':docs').docsDir, prefix: "$zipRootFolder/docs")
    zipFileSet(dir: project(':docs').samplesDir, prefix: "$zipRootFolder/samples")
}
jdk14AllZip.enabled = project.hasProperty('gradle_retroLibsDir')

artifacts {
    tasks.withType(Zip).each {
        dists it
    }
}

integTestDistDir = file("$buildDir/integ test")
integTestUserDir = file('intTestHomeDir')
integTestGradleHome = null

task intTestImage(dependsOn: [allZip, binZip, srcZip]) << {
    integTestGradleHome = new File(integTestDistDir, "gradle-" + version.toString())
    ant {
        delete(dir: integTestDistDir)
        unzip(dest: integTestDistDir, src: allZip.archivePath)
        chmod(dir: "$integTestGradleHome/bin", perm: "ugo+rx", includes: "**/*")
    }
    WrapperProjectCreator.createProject(new File(integTestGradleHome, 'samples'), binZip.archivePath.parentFile, version.toString())
}

// The integtests depend on dists because of the wrapper test, and userguideSrc because of the int test generated from
// the userguide source
task integTest(type: AntTest, dependsOn: [intTestImage, binZip, allZip, srcZip, ':docs:userguideSrc']) {
    options.systemProperties['integTest.srcDir'] = file('src').absolutePath
    options.systemProperties['integTest.userGuideInfoDir'] = project(':docs').docbookSrc
    options.systemProperties['integTest.userGuideOutputDir'] = new File(project(':docs').samplesSrcDir, "userguideOutput").absolutePath
    options.systemProperties['integTest.gradleUserHomeDir'] = integTestUserDir.absolutePath
    include 'org/gradle/integtests/**/*IntegrationTest.*'

    testClassesDir = project(':core').sourceSets.test.classesDir
    classpath = project(':core').sourceSets.test.runtimeClasspath
    testResultsDir = file('build/test-results')
    testReportDir = file('build/reports/tests')
    testSrcDirs = []
}

integTest.doFirst { task ->
    task.options.systemProperties['integTest.gradleHomeDir'] = integTestGradleHome.absolutePath
    def forkArgs = [:]
    if (noForkIntegTests()) {
        task.options.systemProperties['org.gradle.integtest.nofork'] = "true"
        forkArgs = [forkMode: ForkMode.ONCE, jvmArgs: ['-ea', '-Xmx512m', '-XX:MaxPermSize=256m', '-XX:+HeapDumpOnOutOfMemoryError']]
    } else {
        forkArgs = [forkMode: ForkMode.ONCE, jvmArgs: ['-ea', '-Xmx512m', '-XX:+HeapDumpOnOutOfMemoryError']]
    }
    task.options.fork(forkArgs)
}

boolean noForkIntegTests() {
    if (project.hasProperty('forkIntegTests')) {
        return !Boolean.valueOf(forkIntegTests)
    }
    return gradle.taskGraph.hasTask(':developerBuild')
}

task testedDists(dependsOn: [assemble, check, integTest])

task nightlyBuild(dependsOn: [clean, testedDists, ':docs:uploadDocs'])

task install(dependsOn: binZip, description: 'Installs the distribution into directory $gradle_installPath') << {
    ant.delete(dir: installDir)
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        windowsInstall()
    } else {
        asternixInstall()
    }
    ant.move(file: "${installDir.parentFile}/$zipRootFolder", tofile: installDir)
}

gradle.taskGraph.whenReady { graph ->
    if (graph.hasTask(install)) {
        // Do this early to ensure that the properties we need have been set, and fail early
        installDir = file("$gradle_installPath")
        if (installDir.file) {
            throw new RuntimeException("Install directory $installDir does not look like a Gradle installation. Cannot delete it to install.")
        }
        if (installDir.directory) {
            File libDir = new File(installDir, "lib")
            if (!libDir.directory || !libDir.list().findAll { it.matches('gradle.*\\.jar')}) {
                throw new RuntimeException("Install directory $installDir does not look like a Gradle installation. Cannot delete it to install.")
            }
        }
    }
}

void windowsInstall() {
    ant.unzip(src: binZip.archivePath, dest: installDir.parentFile)
}

/**
 * We can't use the Ant unzip task, as this task does not preserve the *nix file system permissions of the Gradle zip.
 */
void asternixInstall() {
    ant.exec(executable: "unzip") {
        arg(value: '-q')
        arg(value: '-d')
        arg(value: installDir.parentFile)
        arg(value: "${binZip.archivePath}")
    }
}

uploadDists {
    dependsOn testedDists
}.doFirst {
    it.repositories.add(new WebdavResolver()) {
        name = 'gradleReleases'
        user = codehausUserName
        userPassword = codehausUserPassword
        addArtifactPattern("$distributionUploadUrl/[artifact]-[revision](-[classifier]).[ext]" as String)
    }
}
gradle.taskGraph.whenReady {graph ->
    if (graph.hasTask(uploadDists)) {
        // check properties defined and fail early
        codehausUserName
        codehausUserPassword
    }
}

task developerBuild(dependsOn: [clean, testedDists])
task ciBuild(dependsOn: [clean, testedDists])

task release(dependsOn: [uploadDists, ':docs:uploadDocs']) << {
// todo rewrite release functionality for Git. Until then we have to do tagging and branching manually.
//    svn.release()
}

task wrapper(type: Wrapper, dependsOn: binZip)
wrapper.doFirst {task ->
    task.configure {
        gradleVersion = version
        jarPath = 'wrapper'
    }
}

task rebuildWrapper(dependsOn: [clean, wrapper])

def groovyProjects() {
    subprojects.findAll { project -> project.name != 'docs' }
}
