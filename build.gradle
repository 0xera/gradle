/*
 * Copyright 2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.gradle.build.Install
import org.gradle.build.BuildTypes
import org.gradle.build.TestReportAggregator

defaultTasks 'assemble'
apply plugin: 'java-base'
archivesBaseName = 'gradle'

extensions.buildTypes = new BuildTypes(project)

buildTypes {
    // The minimum to be run before check-in
    preCommitBuild "doc:checkstyleApi", "codeQuality", "classes", "test", noDistTests: true
    quickCheck "doc:checkstyleApi", "codeQuality", "classes", "test", noDistTests: true

    // A full (in-process) test
    developerBuild "check"

    // Used by the first phase of the build pipeline
    quickTest "test", "integTest", noDistTests: true

    // Used for builds to test the code on certain platforms
    platformTest "test", "forkingIntegTest", noDistTests: true, useIncomingDistributions: true

    // Tests using the daemon mode
    daemonTest "waitForDaemonsToDie", "daemonIntegTest", noDistTests: true, useIncomingDistributions: true

    // Used for cross version tests on CI
    crossVersionTest "forkingIntegTest", crossVersionTestsOnly: "", testAllVersions: "", noDistTests: true, useIncomingDistributions: true

    // Used to build production distros and smoke test them
    packageBuild "verifyIsProductionBuildEnvironment", "clean", "buildDists", "distributions:integTest"

    // Used to build production distros and smoke test them
    promotionBuild "verifyIsProductionBuildEnvironment", "clean", "buildDists", "distributions:integTest", "uploadArchives"
}

ext {
    isCiServer = System.getenv().containsKey("TEAMCITY_VERSION")
    isWindows = System.getProperty("os.name").toLowerCase().contains("windows")

    if (project.hasProperty("maxParallelForks")) {
        project.maxParallelForks = Integer.valueOf(project.maxParallelForks)
    } else {
        ext.maxParallelForks = Math.max(2, (int) (Runtime.runtime.availableProcessors() / 2))
    }

    if (project.hasProperty("useIncomingDistributions")) {
        project.useIncomingDistributions = true
    } else {
        ext.useIncomingDistributions = false
    }
}

apply from: "gradle/buildReceipt.gradle"
apply from: "gradle/incomingDistributions.gradle"
apply from: "gradle/versioning.gradle"
apply from: "gradle/dependencies.gradle"
apply from: "gradle/wrapper.gradle"

allprojects {
    version = rootProject.version
    group = 'org.gradle'

    repositories {
        maven { url 'http://repo.gradle.org/gradle/libs' }
    }
}

configure(groovyProjects()) {
    apply from: "$rootDir/gradle/groovyProject.gradle"
}

configure(publishedProjects()) {
    apply from: "$rootDir/gradle/publish.gradle"
}

allprojects {
    apply from: "$rootDir/gradle/codeQuality.gradle"
    apply from: "$rootDir/gradle/testWithUnknownOS.gradle"
}

apply from: "gradle/idea.gradle"
apply from: "gradle/eclipse.gradle"

configurations {
    dists
    runtime {
        visible = false
    }
    plugins {
        visible = false
    }
    testRuntime {
        extendsFrom runtime
        extendsFrom plugins
    }
}

dependencies {
    runtime project(':launcher')
    plugins pluginProjects()
    plugins project(':coreImpl')
}

evaluationDependsOn(':docs')
evaluationDependsOn(':integTest')

task waitForDaemonsToDie {
    onlyIf { isCiServer && isWindows }
    doLast {
        def mins = 3
        println "I'm waiting for $mins mins so that existing daemons can die with honour. It's a workaround until we fix it properly."
        sleep mins * 60 * 1000
    }
}

clean.dependsOn subprojects.collect { "$it.path:clean" }

task check(overwrite: true, dependsOn: groovyProjects()*.check)
check.dependsOn ':docs:checkstyleApi'
configure(groovyProjects()) {
    check.dependsOn ":docs:checkstyleApi"
}

task test(overwrite: true, dependsOn: groovyProjects()*.test)
task uploadArchives(dependsOn: publishedProjects()*.uploadArchives)
task publishLocalArchives(dependsOn: publishedProjects()*.publishLocalArchives)

task aggregateTestReports(type: TestReportAggregator) {
    testReportDir = reporting.file("tests")
    testResultsDir = file("${buildDir}/test-results")
    projects = subprojects
}

ext.zipRootFolder = "$archivesBaseName-${-> version}"

ext.binDistImage = copySpec {
    from('src/toplevel') {
        exclude 'media/**'
        expand(version: version)
    }
    from('src/toplevel') {
        include 'media/**'
    }
    from project(':docs').outputs.distDocs
    into('bin') {
        from { project(':launcher').startScripts.outputs.files }
        fileMode = 0755
    }
    into('lib') {
        from configurations.runtime
        into('plugins') {
            from configurations.plugins - configurations.runtime
        }
    }
}

ext.allDistImage = copySpec {
    with binDistImage
    into('src') {
        from groovyProjects().collect {project -> project.sourceSets.main.allSource }
    }
    into('docs') {
        from project(':docs').outputs.docs
    }
    into('samples') {
        from project(':docs').outputs.samples
    }
}

task allZip(type: Zip) {
    classifier = 'all'
    into(zipRootFolder) {
        with allDistImage
    }
}

task binZip(type: Zip) {
    classifier = 'bin'
    into(zipRootFolder) {
        with binDistImage
    }
}

task srcZip(type: Zip) {
    classifier = 'src'
    into(zipRootFolder) {
        from('gradlew') {
            fileMode = 0755
        }
        from(projectDir) {
            def spec = delegate
            ['buildSrc', 'subprojects/*'].each {
                spec.include "$it/*.gradle"
                spec.include "$it/src/"
            }
            include 'config/'
            include 'gradle/'
            include 'src/'
            include '*.gradle'
            include 'wrapper/'
            include 'gradlew.bat'
        }
    }
}

task outputsZip(type: Zip) {
    archiveName "outputs.zip"
    from(createBuildReceipt)
    ["all", "bin", "src"].each { from(tasks["${it}Zip"]) }
}

artifacts {
    dists allZip, binZip, srcZip
}

task intTestImage(type: Sync) {
    into file("$buildDir/integ test")
}

if (useIncomingDistributions) {
    task unpackIncomingAllDistribution(type: Sync) {
        from zipTree(incomingAllDistribution)
        into "$buildDir/tmp/unpacked-incoming-all-distribution"
    }

    // Compensate for the top level dir in the zip
    def unpackedPath = "$unpackIncomingAllDistribution.destinationDir/${incomingAllDistribution.name - "-all.zip"}"

    intTestImage {
        dependsOn unpackIncomingAllDistribution
        from unpackedPath
    }
} else {
    intTestImage {
        with binDistImage
        into "samples", {
            from project(":docs").samples
        }
        doLast { task ->
            ant.chmod(dir: "$destinationDir/bin", perm: "ugo+rx", includes: "**/*")
        }
    }
}

task install(type: Install) {
    description = 'Installs the minimal distribution into directory $gradle_installPath'
    group = 'build'
    dependsOn binZip.taskDependencies
    with binDistImage
    installDirPropertyName = 'gradle_installPath'
}

task installAll(type: Install) {
    description = 'Installs the full distribution into directory $gradle_installPath'
    group = 'build'
    dependsOn allZip.taskDependencies
    with allDistImage
    installDirPropertyName = 'gradle_installPath'
}

task testedDists(dependsOn: [check]) {
    outputs.files configurations.dists.allArtifacts.files
}

gradle.taskGraph.whenReady {graph ->
    if (graph.hasTask(uploadArchives)) {
        // check properties defined and fail early
        artifactoryUserName
        artifactoryUserPassword
    }
}

task verifyIsProductionBuildEnvironment << {
    assert Jvm.current().isJava7() : "Must use a Java 7 compatible JVM to perform this build. Current JVM is ${Jvm.current()}"
    def systemCharset = java.nio.charset.Charset.defaultCharset().name()
    assert systemCharset == "UTF-8" : "Platform encoding must be UTF-8. Is currently $systemCharset. Set -Dfile.encoding=UTF-8."
}

if (isCiServer) {
    subprojects { reporting.baseDir "$rootProject.reporting.baseDir/${path.replaceFirst(':', '').replaceAll(':', '.')}" }
}

def groovyProjects() {
    subprojects.findAll { !(it.name in ["docs"]) }
}

def publishedProjects() {
    [project(':core'), project(':toolingApi'), project(':wrapper'), project(':baseServices'), project(':messaging')]
}

def pluginProjects() {
    ['plugins', 'codeQuality', 'jetty', 'antlr', 'wrapper', 'osgi', 'maven', 'ide', 'announce', 'scala', 'sonar', 'signing', 'cpp', 'ear', 'javascript', 'migration'].collect {
        project(it)
    }
}

