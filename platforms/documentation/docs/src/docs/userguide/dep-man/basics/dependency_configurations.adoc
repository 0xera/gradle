// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[dependency-configurations]]
= 2. Dependency Configurations

Every dependency declared for a Gradle project applies to a specific scope.
For example some dependencies should be used for compiling source code whereas others only need to be available at runtime.

Dependency configurations are a way to define different sets of dependencies for different purposes within a project.
They determine how and when dependencies are used in various stages of the build process.

Configurations are a fundamental part of dependency resolution in Gradle.

[[sec:what-are-dependency-configurations]]
== Understanding dependency configurations

Gradle represents the scope of a dependency with the help of a link:{groovyDslPath}/org.gradle.api.artifacts.Configuration.html[Configuration].
Every configuration can be identified by a unique name.

Many Gradle plugins add pre-defined configurations to your project.

image::dependency-management-configurations.png[]

The <<java_plugin.adoc#sec:java_plugin_and_dependency_management,Java plugin>>, for example, adds configurations to represent the various classpaths it needs for source code compilation, executing tests, and more.
Here is a snapshot of those configurations:

1. `implementation`: Used for dependencies required to compile the main source set. These dependencies are not exposed to consumers of the module.
+
[source,kotlin]
----
dependencies {
    implementation("com.google.guava:guava:30.1.1-jre")
}
----
2. `api`: Used in libraries to expose dependencies to consumers. Dependencies declared here are available to consumers that depend on this library.
+
[source,kotlin]
----
dependencies {
    api("org.apache.commons:commons-lang3:3.12.0")
}
----
3. `apiElements`: Used to expose the API of the project to consumers. Includes dependencies needed to compile against the API, not for internal implementation.
+
[source,kotlin]
----
configurations {
    apiElements {
        canBeResolved = false
        canBeConsumed = true
    }
}

artifacts {
    apiElements(tasks.jar)
}
----
4. `runtimeClasspath`: Used to resolves dependencies required at runtime. Includes compile-time and runtime dependencies.
+
[source,kotlin]
----
dependencies {
    runtimeOnly("org.springframework:spring-core:5.3.8")
}

tasks.run {
    classpath = configurations.runtimeClasspath
}
----

Note that the <<swift_application_plugin.adoc#swift_application_plugin, Swift Application plugin>>, adds many different configurations such as `mainDebugImplementation` and `nativeRuntimeDebug`.

[[sec:resolvable-consumable-configs]]
== Understanding resolvable and consumable configurations

In the context of dependency resolution, it is useful to distinguish between a _consumer_ and a _producer_.
Along these lines, configurations have at least 3 different roles:

1. to declare dependencies
2. as a _consumer_, to resolve a set of dependencies to files
3. as a _producer_, to expose artifacts and their dependencies for consumption by other projects

Gradle configurations can be categorized as resolvable, consumable, or both, depending on their purpose in the build process:

- *Resolvable Configurations*: Provide dependencies needed for task execution (e.g., `compileClasspath`).
- *Consumable Configurations*: Expose artifacts for other projects to consume (e.g., `runtimeElements`).
- *Dual-Purpose Configurations*: Can serve as both sources and sinks for dependencies.

Let's once again look at the available configurations for a Java project which applies the Java plugin:

image::java-plugin-configurations.png[]

The dependency declaration configurations (`compileOnlyApi`, `api`, `compileOnly`, `implementation`, `runtimeOnly`) focus on declaring and managing dependencies based on their usage (compile time, runtime, API exposure):

[source,kotlin]
----
dependencies {
    api("org.apache.commons:commons-lang3:3.12.0")
    implementation("com.google.guava:guava:30.1.1-jre")
    compileOnly("org.projectlombok:lombok:1.18.20")
    runtimeOnly("mysql:mysql-connector-java:8.0.23")
}
----

The consuming configurations (`apiElements`, `runtimeElements`) focus on exposing specific parts of the project (API, runtime) to consumers:

[source,kotlin]
----
configurations {
    runtimeElements {
        canBeResolved = false
        canBeConsumed = true
    }
}
----

The resolving configurations (`runtimeClasspath`, `compileClasspath`) focus on resolving dependencies needed at different stages of the build process (compilation, runtime):

[source,kotlin]
----
tasks.compileJava {
    classpath = configurations.compileClasspath
}
----

For example, to express that an application `app` _depends on_ library `lib`, _at least_ one configuration is required:

====
include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=declare-configuration]"]
include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=declare-configuration]"]
====

Configurations can inherit dependencies from other configurations by extending from them.

Notice that the code above doesn't specify the intended _consumer_ of this configuration or how it is meant to be _used_.

Let's say `lib` is a Java library that might expose different components, such as its API, implementation, or test fixtures.
Depending on the task we're performing (e.g., compiling against the API of `lib`, executing the application, compiling tests), we may need to change how we resolve the dependencies of `app`.

To address this problem, you'll often find companion configurations that are designed to unambiguously declare the usage:

====
include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=concrete-classpath]"]
include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=concrete-classpath]"]
====

At this point, we have three different configurations with distinct roles:

- `someConfiguration` declares the dependencies of the application. It is simply a collection of dependencies.
- `compileClasspath` and `runtimeClasspath` are configurations meant to be _resolved_: when resolved, they should contain the compile classpath and runtime classpath of the application, respectively.

This distinction is represented by the `canBeResolved` flag in the `Configuration` type.

- **Resolvable Configuration (`canBeResolved=true`)**: A configuration that can be resolved allows Gradle to compute a dependency graph because it contains all necessary information for resolution.
+
When resolved, it produces a dependency graph, resolves the components, and eventually retrieves artifacts.
- **Non-Resolvable Configuration (`canBeResolved=false`)**: A configuration that is not meant to be resolved.
+
It is only used to _declare dependencies_. Depending on the usage (compile classpath, runtime classpath), it can resolve to different graphs.
+
Attempting to resolve a configuration with `canBeResolved` set to `false` results in an error.

To some extent, this is similar to an abstract class (`canBeResolved=false`) that is not supposed to be instantiated, and a concrete class extending the abstract class (`canBeResolved=true`).
A resolvable configuration will extend at least one non-resolvable configuration (and may extend more than one).

On the producer side (library project), configurations represent what can be consumed.
For example, a library may expose an API or a runtime, attaching artifacts to either one or both.
Typically, to compile against `lib`, we need its API but not its runtime dependencies. Thus, the `lib` project will expose an `apiElements` configuration aimed at consumers seeking its API.
Such a configuration is consumable but not meant to be resolved.

This is expressed via the _canBeConsumed_ flag of a `Configuration`:

====
include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=setup-configurations]"]
include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=setup-configurations]"]
====

In short, a configuration's role is determined by the `canBeResolved` and `canBeConsumed` flag combinations:

|===
|Configuration role|can be resolved|can be consumed
|Dependency Scope|false|false
|Resolve for certain usage|true|false
|Exposed to consumers|false|true
|Legacy, don't use|true|true
|===

Both flags have a default value of `true`.

== Viewing configurations

To focus on the information about one dependency configuration, provide the optional parameter `--configuration`.
Just like <<command_line_interface#sec:name_abbreviation, project and task names>>, Gradle accepts abbreviated names to select a dependency configuration.
For example, you can specify `tRC` instead of `testRuntimeClasspath` if the pattern matches to a single dependency configuration.
Both of the following examples show dependencies in the `testRuntimeClasspath` dependency configuration of a Java project:

----
> gradle -q dependencies --configuration testRuntimeClasspath
----

[[sec:defining-custom-configurations]]
== Creating custom configurations

You can define configurations yourself, so-called _custom configurations_.
A custom configuration is useful for separating the scope of dependencies needed for a dedicated purpose.

Consider a project that uses the link:https://www.eclipse.org/jgit/[JGit library] to execute Source Control Management (SCM) operations for a release process.
You can declare dependencies for external tooling with the help of a <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,custom dependency configuration>>.
This avoids polluting other contexts, such as the compilation classpath for your production source code.

The following example declares a custom dependency configuration named "scm" that contains the JGit dependency:

====
include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependenciesReport/kotlin",files="build.gradle.kts[tags=dependency-declaration]"]
include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependenciesReport/groovy",files="build.gradle[tags=dependency-declaration]"]
====

Use the following command to view a dependency tree for the `scm` dependency configuration:

----
> gradle -q dependencies --configuration scm
include::{snippetsPath}/dependencyManagement/inspectingDependencies-dependenciesReport/tests/dependencyReport.out[]
----
