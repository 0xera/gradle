// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[understanding_dependency_resolution]]
= 6. Dependency Resolution

Dependency resolution in Gradle involves two main steps:

1. **Graph Resolution**
2. **Artifact Resolution**

== 1. Graph Resolution

*Graph resolution* is an iterative process with two key phases:

- **Conflict Resolution**: When a new dependency is introduced, Gradle determines which version should be added to the graph.
- **Metadata Retrieval**: Once a specific dependency (a *module* with a version) is identified, its metadata is fetched to add its own dependencies to the graph.

=== 1. Finding dependencies

Gradle first identifies all project and external (*module*) dependencies declared in the build script.

- A *module* is a discrete unit of software that can be built and published, such as link:https://mvnrepository.com/artifact/com.google.guava/guava[`com.google.guava:guava`].
- Each version of a *module* is referred to as a *component*, such as link:https://mvnrepository.com/artifact/com.google.guava/guava/33.3.0-jre[`com.google.guava:guava:33.3.0-jre`].

In the example below, the *component* `com.google.guava:guava:33.0.0-jre` is added as a dependency to the `implementation` *configuration* in a Java application:

[source,kotlin]
.build.gradle.kts
----
dependencies {
    implementation("com.google.guava:guava:33.0.0-jre")
}
----

=== 2. Perform conflict resolution

Gradle identifies and resolves any version conflicts that occur when different *modules* in the dependency graph rely on different *versions* of the same library.

Even though a user might declare version `33.0.0-jre` of a *module*, this may not be the version ultimately used in the build.
Gradle’s conflict resolution strategy, which defaults to selecting the highest version, determines the outcome.

However, Gradle APIs can be used to change the outcome:

- **Resolution Rules**: Gradle allows configuring rules to enforce specific versions, blacklist certain versions, or substitute modules as needed.
- **Dependency Substitution**: Rules defined in the build script can replace one dependency with another, alter versions, or redirect dependencies to different modules.
- **Dynamic Versions**: If dependencies are defined with dynamic versions (e.g., `1.0.+`) or version ranges (e.g., `[1.0, 2.0)`), Gradle resolves these to specific versions by querying the repositories.
- **Dependency Locking**: If enabled, Gradle checks lock files to ensure consistent versions across builds, preventing unexpected changes in dependencies.

In the example, Gradle selects the *component* `com.google.guava:guava:33.0.0-jre` (the `33.0.0-jre` version of the `com.google.guava:guava` *module*).

=== 3. Retrieve the metadata

Once Gradle has determined which version to use, it fetches the *metadata* for the *component* from an `ivy`, `module`, or link:https://repo1.maven.org/maven2/com/google/guava/guava/33.0.0-jre/guava-33.0.0-jre.pom[`pom`] file in the repository.

Here’s a snapshot of the *metadata* for `com.google.guava:guava:33.0.0-jre`:

[source,xml]
----
<variant name="jreApiElements">
    <artifact>guava-33.0.0-jre.jar</artifact>
    <transitiveDependencies count="6">
        <dependency>com.google.guava:failureaccess:1.0.1</dependency>
        <dependency>com.google.guava:listenablefuture:9999.0</dependency>
        <dependency>com.google.code.findbugs:jsr305:3.0.2</dependency>
        <dependency>org.checkerframework:checker-qual:3.12.0</dependency>
        <dependency>com.google.errorprone:error_prone_annotations:2.26.1</dependency>
        <dependency>com.google.j2objc:j2objc-annotations:2.8</dependency>
    </transitiveDependencies>
</variant>
<variant name="jreRuntimeElements">
    <artifact>guava-33.0.0-jre.jar</artifact>
    <transitiveDependencies count="5">
        <dependency>com.google.guava:failureaccess:1.0.1</dependency>
        <dependency>com.google.guava:listenablefuture:9999.0</dependency>
        <dependency>com.google.code.findbugs:jsr305:3.0.2</dependency>
        <dependency>org.checkerframework:checker-qual:3.12.0</dependency>
        <dependency>com.google.errorprone:error_prone_annotations:2.26.1</dependency>
    </transitiveDependencies>
</variant>
----

As you can see, the `com.google.guava:guava:33.0.0-jre` *component* offers two *variants*:

- The `jreApiElements` *variant* includes dependencies for compiling projects using Guava on the JRE platform.
- The `jreRuntimeElements` *variant* includes dependencies essential for runtime.

A *variant* is a specific version of a *component* tailored for a particular use case or environment.
*Variants* allow you to provide different versions of your *component* depending on the context in which it’s used.

Each *variant* consists of a set of *artifacts* and defines a set of dependencies.
The `jreApiElements` variant resolves to a *component*, the actual artifact (the `guava-33.0.0-jre.jar` file) included in your build.

=== 4. Update the graph

Gradle builds a dependency graph that represents all the project's dependencies and their relationships.
This graph includes both direct dependencies (explicitly declared in the build script) and transitive dependencies (dependencies of the direct dependencies).

The dependency graph is made up of _nodes_ where:

- Each _node_ represents a *variant*.
- A *variant* is resolved to a *component*.

These _nodes_ are connected by edges, representing the dependencies between *components*.
The edges indicate how one component relies on another.

For instance, if your project depends on Guava, and Guava depends on `jsr305`, the edge in the graph represents that `jsr305` is a dependency of Guava's variant.

You can visualize a simple dependency graph by running the following command in your Java project:

[source,text]
----
$ ./gradlew app:dependencies

[...]

compileClasspath - Compile classpath for source set 'main'.
\--- com.google.guava:guava:33.0.0-jre
     +--- com.google.guava:failureaccess:1.0.2
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.41.0
     +--- com.google.errorprone:error_prone_annotations:2.23.0
     \--- com.google.j2objc:j2objc-annotations:2.8

runtimeClasspath - Runtime classpath of source set 'main'.
\--- com.google.guava:guava:33.0.0-jre
     +--- com.google.guava:failureaccess:1.0.2
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.41.0
     \--- com.google.errorprone:error_prone_annotations:2.23.0

----

In this output, `compileClasspath` and `runtimeClasspath` represent specific configurations in the project, corresponding to different *variants* of the dependencies.
Each *variant* is tied to a specific *component* version.

For a more detailed view of which *variant* Gradle resolved for the `runtimeClasspath` configuration, you can run:

[source,text]
----
$ ./gradlew :app:dependencyInsight --configuration runtimeClasspath --dependency com.google.guava:guava:33.0.0-jre

> Task :app:dependencyInsight

com.google.guava:guava:33.0.0-jre
  Variant jreRuntimeElements:
    | Attribute Name                 | Provided     | Requested    |
    |--------------------------------|--------------|--------------|
    | org.gradle.status              | release      |              |
    | org.gradle.category            | library      | library      |
    | org.gradle.dependency.bundling | external     | external     |
    | org.gradle.jvm.environment     | standard-jvm | standard-jvm |
    | org.gradle.jvm.version         | 8            | 11           |
    | org.gradle.libraryelements     | jar          | jar          |
    | org.gradle.usage               | java-runtime | java-runtime |

com.google.guava:guava:33.0.0-jre
\--- runtimeClasspath
----

In this example, Gradle uses the `jreRuntimeElements` variant* of `guava` for the `runtimeClasspath` configuration.

== 2. Artifact Resolution

**Artifact resolution** occurs after the dependency graph is constructed.
It focuses on fetching the necessary physical files (*artifacts*) for the build and ensuring they are available, valid, and correctly versioned.

This process uses the resolved graph and repository definitions to produce the required files as output.

=== 1. Fetching artifacts

Gradle locates and downloads the actual artifacts (such as JAR files, ZIP files, etc.) required by the project.
These artifacts correspond to the dependencies identified during graph resolution.

In our example, Gradle resolved the `jreRuntimeElements` variant of `com.google.guava:guava:33.0.0-jre` during the dependency graph resolution.
The artifact resolution phase retrieves the corresponding JAR file (`guava-33.0.0-jre.jar`) and its transitive dependencies, like `jsr305` or `failureaccess`, from the specified repositories.

=== 2. Artifact resolution rules

If any artifact resolution rules are defined in the build script, they are applied at this stage.
These rules might involve substituting one artifact for another or enforcing specific artifact versions.

In our example, if the build script included a rule to substitute `com.google.guava:guava:33.0.0-jre` with a custom-built version, Gradle would apply this rule during artifact resolution, ensuring the correct version is used according to the project's specific needs.

== Summary

The dependency resolution engine is variant-aware and selects one or more *variants* of each *component* based on your build requirements.
It may fail if the *variant* selection result is ambiguous, meaning that Gradle does not have enough information to select one of multiple mutual exclusive variants.

[.text-right]
**Next Step:** <<variant_aware_resolution.adoc#variant_aware_resolution,View Variant-Aware Dependency Resolution in Action>> >>
