// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[understanding_dependency_resolution]]
= 6. Dependency Resolution

Dependency resolution in Gradle can largely be thought of as a two-step process:

1. _Graph resolution_
2. _Artifact resolution_

== 1. Graph Resolution

During the first phase of Gradle's dependency resolution process, known as **graph resolution**, the following steps occur:

=== 1. **Dependency Declaration Parsing:**

Gradle first reads all the dependencies declared in the build script.

A *module* is essentially a discrete unit of software that can be built and published such as `com.google.guava:guava`.

Each version of a *module* is a *component*.
A *component* refers to one published library version such as `com.google.guava:guava:33.3.0-jre`.

In the following example of an arbitrary Java app, the *component* `com.google.guava:guava:33.0.0-jre` (the version `33.0.0-jre` of the `com.google.guava:guava` module) is added as a dependency to the `implementation` *configuration* in the build file:

[source,kotlin]
----
dependencies {
    implementation("com.google.guava:guava:33.0.0-jre")
}
----

=== 2. **Dependency MetaData:**

Gradle constructs a dependency graph, which is a representation of all the project’s dependencies and how they relate to each other.
+
This graph includes both direct dependencies (those explicitly declared in the build script) and transitive dependencies (those brought in by the direct dependencies).
+
In the case of `com.google.guava:guava`, the following transitive dependencies are added:

* `com.google.guava:failureaccess`
* `com.google.guava:listenablefuture`
* `com.google.code.findbugs:jsr305`
* `org.checkerframework:checker-qual`
* `com.google.errorprone:error_prone_annotations`
* `com.google.j2objc:j2objc-annotations`

3. **Conflict Resolution:**
- Gradle identifies and resolves any version conflicts that may arise when different modules in the graph depend on different versions of the same library.
+
This is where Gradle's conflict resolution strategy (e.g., picking the highest version by default) comes into play.
+
In the example, Gradle picks the *component* `com.google.guava:guava:33.0.0-jre` (the version `33.0.0-jre` of the `com.google.guava:guava` module).

4. **Variant Selection:**
- Gradle finds the *metadata* of the *component* from an `ivy`, `module`, or link:https://repo1.maven.org/maven2/com/google/guava/guava/33.0.0-jre/guava-33.0.0-jre.pom[`pom`] file in the repository of the dependency.
+
In the example, a snapshot of the *metadata* from `com.google.guava:guava:33.0.0-jre`:

* Variants: 2
** Compile Variant: `compileClasspath`
*** Transitive Dependencies: 6
**** `com.google.guava:failureaccess:1.0.1`
**** `com.google.guava:listenablefuture:9999.0`
**** `com.google.code.findbugs:jsr305:3.0.2`
**** `org.checkerframework:checker-qual:3.12.0`
**** `com.google.errorprone:error_prone_annotations:2.26.1`
**** `com.google.j2objc:j2objc-annotations:2.8`
** Runtime Variant: `runtimeClasspath`
*** Transitive Dependencies: 5
**** `com.google.guava:failureaccess:1.0.1`
**** `com.google.guava:listenablefuture:9999.0`
**** `com.google.code.findbugs:jsr305:3.0.2`
**** `org.checkerframework:checker-qual:3.12.0`
**** `com.google.errorprone:error_prone_annotations:2.26.1`

+
What's important to note here is the two *variants* of `com.google.guava:guava:33.0.0-jre` are available.
Therefore, each *component* consists of one or more variants.
A *variant* is a specific version of a *component* tailored for a particular use case or environment.
Variants allow you to define different versions of your *module* depending on the context in which it is used.
A *variant* consists of a set of artifacts and defines a set of dependencies.

- If the project has multiple variants (like `apiElements`, `runtimeElements`, or custom variants), Gradle selects the appropriate variant of each dependency based on attributes. This is especially relevant for projects with different configurations for different environments (e.g., Java versions, platforms, etc.).

5. **Resolution Rules:**
- Gradle applies resolution rules that may be configured, such as forcing a specific version of a dependency, blacklisting versions, or substituting modules.
- Gradle applies any dependency substitution rules defined in the build script. These rules can replace one dependency with another, modify versions, or even redirect to a different module.
- If any dependencies are defined with dynamic versions (e.g., `1.0.+`) or version ranges (e.g., `[1.0, 2.0)`), Gradle resolves these to specific versions by consulting the repositories.
- If dependency locking is enabled, Gradle checks the lock files to ensure that the same versions are used across builds, preventing unexpected changes in dependencies.


With the information from the *metadata*, Gradle builds a dependency graph made up of _nodes_:

- each _node_ in the graph is a *variant*.
- each one gets resolved to a *component*.

== 2. Artifact Resolution

In the dependency resolution process, the second step, **artifact resolution**, occurs after the dependency graph has been constructed.

Here's what happens during artifact resolution:

1. **Fetching Artifacts:** Gradle locates and downloads the actual artifacts (such as JAR files, ZIP files, etc.) required by the project. These artifacts correspond to the dependencies identified during graph resolution.

2. **Repository Interaction:** Gradle queries the repositories specified in the build script (like Maven Central, JCenter, or a custom repository) to find and fetch the artifacts. This may involve resolving the exact version of the artifacts if dynamic versions or version ranges are used.

3. **Artifact Caching:** Once an artifact is downloaded, Gradle stores it in its local cache (usually in the `~/.gradle` directory). This ensures that subsequent builds don't need to re-download the same artifacts, improving build performance.

4. **Verification and Integrity Checks:** Gradle may perform checksum verification or other integrity checks to ensure that the downloaded artifacts are not corrupted.

5. **Artifact Resolution Rules:** If any artifact resolution rules are defined in the build script, they are applied at this stage. These rules might involve substituting one artifact for another or enforcing specific artifact versions.

6. **Failure Handling:** If Gradle cannot resolve an artifact (due to network issues, missing repositories, etc.), it will fail the build with a descriptive error message. Depending on the configuration, Gradle might retry the download or fall back to alternative repositories.

Artifact resolution takes the resolved graph and repository definitions as input and produces a set of files as output.

In summary, artifact resolution is all about fetching the physical files (artifacts) necessary for the build, ensuring they are available, valid, and correctly versioned. This process is crucial for executing the build with the right dependencies.


[.text-right]
**Next Step:** <<variant_aware_resolution.adoc#variant_aware_resolution,Learn about Variant Aware Dependency Resolution>> >>








The dependency resolution engine is variant-aware and selects one or more *variants* of each *component* based on your build requirements.
It may fail if the *variant* selection result is ambiguous, meaning that Gradle does not have enough information to select one of multiple mutual exclusive variants.

Graph resolution takes the set of dependency declarations and repository definitions as input and produces a resolved graph as output, where each node is a specific version of a component and the edges represents the dependencies between the components.

Graph resolution itself is single threaded. We process the graph one node (variant) at a time. For each node we look at all its dependencies, determine what versions they target, and download the metadata for all dependencies (for that node) at once. So it’s a bunch of parallel downloads separated by single threaded logic, over and over again — for a single graph. See the logic.

You can the dependency graph of our `Java app` by running `./gradlew app:dependencies`:

[source,text]
----
$ ./gradlew app:dependencies

[...]

runtimeClasspath - Runtime classpath of source set 'main'.
\--- com.google.guava:guava:33.0.0-jre
     +--- com.google.guava:failureaccess:1.0.2
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.41.0
     \--- com.google.errorprone:error_prone_annotations:2.23.0

[...]
----

What it tells us is that for the runtimeClasspath the `app` will use version `33.0.0-jre` of `guava`.

Let’s look at the attributes we find on the runtimeElements configuration on the `app`:

[source,text]
----
$ ./gradlew :app:outgoingVariants --variant runtimeElements

> Task :app:outgoingVariants

--------------------------------------------------
Variant runtimeElements
--------------------------------------------------
Runtime elements for the 'main' feature.

Capabilities
    - artifact-tutorial:app:unspecified (default capability)
Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 11
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-runtime
Artifacts
    - build/libs/app.jar (artifactType = jar)

----

What it tells us is that the `app` produces variants with 5 attributes:

- `org.gradle.category` tells us that this variant represents a _library_
- `org.gradle.dependency.bundling` tells us that the dependencies of this variant are found as jars (they are not, for example, repackaged inside the jar)
- `org.gradle.jvm.version` tells us that the minimum Java version this library supports is Java 11
- `org.gradle.libraryelements` tells us this variant contains all elements found in a jar (classes and resources)
- `org.gradle.usage` says that this variant is a Java runtime, therefore suitable for a Java compiler but also at runtime

Let’s look at the attributes we find on the runtimeClasspath configuration of `com.google.guava:guava:33.0.0-jre`:

[source,text]
----
$ ./gradlew :app:dependencyInsight --configuration runtimeClasspath --dependency com.google.guava:guava:33.0.0-jre

> Task :app:dependencyInsight

com.google.guava:guava:33.0.0-jre
  Variant jreRuntimeElements:
    | Attribute Name                 | Provided     | Requested    |
    |--------------------------------|--------------|--------------|
    | org.gradle.status              | release      |              |
    | org.gradle.category            | library      | library      |
    | org.gradle.dependency.bundling | external     | external     |
    | org.gradle.jvm.environment     | standard-jvm | standard-jvm |
    | org.gradle.jvm.version         | 8            | 11           |
    | org.gradle.libraryelements     | jar          | jar          |
    | org.gradle.usage               | java-runtime | java-runtime |

com.google.guava:guava:33.0.0-jre
\--- runtimeClasspath
----

What it tells us is that the `jreRuntimeElements` variant of `guava` has several key attributes:

- `org.gradle.status` indicates that this is a _release_ variant of Guava.
- `org.gradle.category` tells us that this variant also represents a _library_.
- `org.gradle.dependency.bundling` confirms that Guava’s dependencies are _external_ and not repackaged inside the jar.
- `org.gradle.jvm.environment` specifies that the Guava library targets a _standard JVM_ environment.
- `org.gradle.jvm.version` tells us that Guava supports a minimum Java version of _8_, which is lower than the requested version (_11_) by the `app`.
- `org.gradle.libraryelements` indicates that this variant contains elements found in a _jar_ (classes and resources).
- `org.gradle.usage` specifies that this variant is suitable for a _Java runtime_.

By comparing these attributes with those of the `app`, we can see how Gradle uses this information to determine compatibility between dependencies, ensuring that the correct artifacts are selected during dependency resolution. For example, despite the Java version difference (Java 8 vs. 11), the other attributes like usage and library elements align, making this variant suitable for the `runtimeClasspath` configuration of the `app`.
