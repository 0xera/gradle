
[[sec:archive_contents]]
=== Using archives as file trees

An archive is a directory and file hierarchy packed into a single file. In other words, it's a special case of a file tree, and that's exactly how Gradle treats archives. Instead of using the `fileTree()` method, which only works on normal file systems, you use the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)[Project.zipTree(java.lang.Object)] and link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:tarTree(java.lang.Object)[Project.tarTree(java.lang.Object)] methods to wrap archive files of the corresponding type (note that JAR, WAR and EAR files are ZIPs). Both methods return `FileTree` instances that you can then use in the same way as normal file trees. For example, you can extract some or all of the files of an archive by copying its contents to some directory on the file system. Or you can merge one archive into another.

Here are some simple examples of creating archive-based file trees:

.Using an archive as a file tree
====
include::sample[dir="snippets/files/fileTrees/kotlin",files="build.gradle.kts[tags=archive-trees]"]
include::sample[dir="snippets/files/fileTrees/groovy",files="build.gradle[tags=archive-trees]"]
====

You can see a practical example of extracting an archive file <<#sec:unpacking_archives_example,in among the common scenarios>> we cover.

[[sec:specifying_multiple_files]]
=== Understanding implicit conversion to file collections

Many objects in Gradle have properties which accept a set of input files.
For example, the link:{groovyDslPath}/org.gradle.api.tasks.compile.JavaCompile.html[JavaCompile] task has a `source` property that defines the source files to compile.
You can set the value of this property using any of the types supported by the <<#sec:file_collections,files()>> method, as mentioned in the API docs.
This means you can, for example, set the property to a `File`, `String`, collection, `FileCollection` or even a closure or `Provider`.

*This is a feature of specific tasks*!
That means implicit conversion will not happen for just any task that has a `FileCollection` or `FileTree` property.
If you want to know whether implicit conversion happens in a particular situation, you will need to read the relevant documentation, such as the corresponding task's API docs.
Alternatively, you can remove all doubt by explicitly using link:{javadocPath}/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object++...++-[ProjectLayout.files(java.lang.Object++...++)] in your build.

Here are some examples of the different types of arguments that the `source` property can take:

.Specifying a set of files
====
include::sample[dir="snippets/files/inputFiles/kotlin",files="build.gradle.kts[tags=set-input-files]"]
include::sample[dir="snippets/files/inputFiles/groovy",files="build.gradle[tags=set-input-files]"]
====

One other thing to note is that properties like `source` have corresponding methods in core Gradle tasks. Those methods follow the convention of _appending_ to collections of values rather than replacing them. Again, this method accepts any of the types supported by the <<#sec:file_collections,files()>> method, as shown here:

.Appending a set of files
====
include::sample[dir="snippets/files/inputFiles/kotlin",files="build.gradle.kts[tags=add-input-files]"]
include::sample[dir="snippets/files/inputFiles/groovy",files="build.gradle[tags=add-input-files]"]
====

As this is a common convention, we recommend that you follow it in your own custom tasks. Specifically, if you plan to add a method to configure a collection-based property, make sure the method appends rather than replaces values.


[[sec:copy_deploy]]
=== Deploying single files into application servers

When working with application servers, you can use a `Copy` task to deploy the application archive (e.g. a WAR file).
Since you are deploying a single file, the destination directory of the `Copy` is the whole deployment directory.
The deployment directory sometimes does contain unreadable files like named pipes, so Gradle may have problems doing up-to-date checks.
In order to support this use-case, you can use link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:doNotTrackState(java.lang.String)[Task.doNotTrackState()].

.Using Copy to deploy a WAR file
====
include::sample[dir="snippets/files/deployWarWithCopy/kotlin",files="build.gradle.kts"]
include::sample[dir="snippets/files/deployWarWithCopy/groovy",files="build.gradle"]
====

[[sec:install_executable]]
=== Installing executables

When you are building a standalone executable, you may want to install this file on your system, so it ends up in your path.
You can use a `Copy` task to install the executable into shared directories like `/usr/local/bin`.
The installation directory probably contains many other executables, some of which may even be unreadable by Gradle.
To support the unreadable files in the `Copy` task's destination directory and to avoid time consuming up-to-date checks, you can use link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:doNotTrackState(java.lang.String)[Task.doNotTrackState()].

.Using Copy to install an executable
====
include::sample[dir="snippets/files/installExecutable/kotlin",files="build.gradle.kts"]
include::sample[dir="snippets/files/installExecutable/groovy",files="build.gradle"]
====


[[sec:reproducible_archives]]
=== Reproducible builds

Sometimes it's desirable to recreate archives exactly the same, byte for byte, on different machines. You want to be sure that building an artifact from source code produces the same result no matter when and where it is built. This is necessary for projects like https://reproducible-builds.org/[reproducible-builds.org].

Reproducing the same byte-for-byte archive poses some challenges since the order of the files in an archive is influenced by the underlying file system. Each time a ZIP, TAR, JAR, WAR or EAR is built from source, the order of the files inside the archive may change. Files that only have a different timestamp also causes differences in archives from build to build. All link:{groovyDslPath}/org.gradle.api.tasks.bundling.AbstractArchiveTask.html[AbstractArchiveTask] (e.g. Jar, Zip) tasks shipped with Gradle include support for producing reproducible archives.

For example, to make a `Zip` task reproducible you need to set link:{groovyDslPath}/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:reproducibleFileOrder[Zip.isReproducibleFileOrder()] to `true` and link:{groovyDslPath}/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:preserveFileTimestamps[Zip.isPreserveFileTimestamps()] to `false`. In order to make all archive tasks in your build reproducible, consider adding the following configuration to your build file:

.Activating reproducible archives
====
include::sample[dir="snippets/files/archives/kotlin",files="build.gradle.kts[tags=reproducible]"]
include::sample[dir="snippets/files/archives/groovy",files="build.gradle[tags=reproducible]"]
====

Often you will want to publish an archive, so that it is usable from another project.
This process is described in <<cross_project_publications.adoc#cross_project_publications,Cross-Project publications>>.
