// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[declaring_dependencies_between_subprojects]]
= Declaring Dependencies between Subprojects

What if one project needs the jar produced by another project on its compile classpath?

What if it also requires the transitive dependencies of the other project?

[[sec:project_jar_dependencies]]
== Depending on another project

This is a common use case for Java multi-project builds.

Gradle offers <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>> for this.
A typical multi-project build has the following layout:

[.multi-language-sample]
=====
[source, kotlin]
----
.
├── buildSrc
│   ...
├── api
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── services
│   └── person-service
│       ├── src
│       │   └──...
│       └── build.gradle.kts
├── shared
│   ├── src
│   │   └──...
│   └── build.gradle.kts
└── settings.gradle.kts
----
=====
[.multi-language-sample]
=====
[source, groovy]
----
.
├── buildSrc
│   ...
├── api
│   ├── src
│   │   └──...
│   └── build.gradle
├── services
│   └── person-service
│       ├── src
│       │   └──...
│       └── build.gradle
├── shared
│   ├── src
│   │   └──...
│   └── build.gradle
└── settings.gradle
----
=====

In this example, there are three projects called `shared`, `api`, and `person-service`:

1. The `person-service` project depends on the other two projects, `shared` and `api`.
2. The `api` project depends on the `shared` project. It has no build script and gets nothing injected by another build script.

We use the `:` separator to define a <<intro_multi_project_builds#sec:project_path,project path>>.
Consult the DSL documentation of link:{groovyDslPath}++/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])++[Settings.include(java.lang.String[\])] for more information about defining project paths.

Shared build logic is extracted into a _convention plugin_ that is applied in the subprojects' build scripts that also define project dependencies:

[[javadependencies_2]]
====
include::sample[dir="snippets/multiproject/dependencies-java/kotlin",files="settings.gradle.kts[];buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[];api/build.gradle.kts[];shared/build.gradle.kts[];services/person-service/build.gradle.kts[]"]
include::sample[dir="snippets/multiproject/dependencies-java/groovy",files="settings.gradle[];buildSrc/src/main/groovy/myproject.java-conventions.gradle[];api/build.gradle[];shared/build.gradle[];services/person-service/build.gradle[]"]
====

A project dependency is a special form of an execution dependency.
It causes the other project to be built first and adds the jar with the classes of the other project to the classpath.
It also adds the dependencies of the other project to the classpath.

If you execute `gradle :api:compile`, first the `shared` project is built, and then the `api` project is built.

IMPORTANT: Project dependencies enable partial multi-project builds.

[[sec:depending_on_output_of_another_project]]
== Depending on artifacts produced by another project

<<#sec:project_jar_dependencies,Project dependencies>> model dependencies between modules.

Effectively, a project depends on the main output of another project.
In a Java-based project, it's usually a JAR file.

Sometimes, you may want to depend on an output produced by another task.
You'll want to ensure the task is executed beforehand to produce that very output.
Declaring a task dependency from one project to another is a poor way to model this relationship and introduces unnecessary coupling.

The recommended way to model such a dependency is to produce the output and mark it as an "outgoing" artifact.

Let's say you are working in a multi-project build with the two subprojects, `producer` and `consumer`.

The subproject `producer` defines a task named `buildInfo` that generates a properties file containing build information (e.g., the project version):

====
include::sample[dir="snippets/multiproject/dependencies-outgoingArtifact/kotlin/",files="producer/build.gradle.kts[]"]
include::sample[dir="snippets/multiproject/dependencies-outgoingArtifact/groovy/",files="producer/build.gradle[]"]
====

You can then map the task provider to its output file, and Gradle will automatically establish a task dependency:

.buildSrc/src/main/java/BuildInfo.java
[source, java]
----
include::{snippetsPath}/multiproject/dependencies-outgoingArtifact/groovy/buildSrc/src/main/java/BuildInfo.java[tags=task]
----

Declaring a project dependency on the producing project involves creating the properties beforehand and making them available to the runtime classpath:

====
include::sample[dir="snippets/multiproject/dependencies-outgoingArtifact/kotlin/",files="consumer/build.gradle.kts[tags=producer-project-dependency]"]
include::sample[dir="snippets/multiproject/dependencies-outgoingArtifact/groovy/",files="consumer/build.gradle[tags=producer-project-dependency]"]
====

The `consumer` now declares a dependency on the outputs of the `producer` project.
The consuming project is able to read the properties file at runtime.

Depending on the main output artifact from another project is only one example.
You could also add `producer` outputs to the `main` source set, which you can depend on in the consuming project.

Gradle has one of the most powerful <<core_dependency_management#sec:dependency-mgmt-in-gradle,dependency management engines>> that allows you to share arbitrary artifacts between projects and let Gradle build them on demand.

For more details see the section on <<cross_project_publications#cross_project_publications,sharing outputs between projects>>.
