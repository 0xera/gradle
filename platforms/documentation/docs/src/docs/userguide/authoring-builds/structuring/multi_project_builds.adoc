// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[multi_project_builds]]
= Structuring Projects with Gradle

A multi-project build in Gradle consists of one root project and one or more subprojects.

Gradle can build the root project and any number of the subprojects in a single execution.

[[sub:project_locations]]
== Project locations

Multi-project builds are represented by a tree with a single root.
Each element in the tree represents a (sub)project.

A (sub)project has <<intro_multi_project_builds#sec:project_path,a path>>, which denotes the position of the (sub)project in the multi-project build tree.

In most cases, the (sub)project path is consistent with its location in the file system.
However, this behavior is configurable if necessary.

The project tree is created in the `settings.gradle(.kts)` file.
The location of the settings file is also the location of the root project.

[[sec:creating_multi_project_builds]]
== A simple build

Let's look at a _basic_ multi-project build example which contains a root project and a single subproject.

The subproject is called `app`:

[.multi-language-sample]
=====
[source, kotlin]
----
.
├── app
│   ...
│   └── build.gradle.kts
└── settings.gradle.kts
----
=====
[.multi-language-sample]
=====
[source, groovy]
----
.
├── app
│   ...
│   └── build.gradle
└── settings.gradle
----
=====

This is the recommended project structure for starting any Gradle project.
The <<build_init_plugin#build_init_plugin,build init plugin>> also generates skeleton projects that follow this structure - a root project with a single subproject:

====
include::sample[dir="snippets/multiproject/basic-multiproject/kotlin",files="settings.gradle.kts[]"]
include::sample[dir="snippets/multiproject/basic-multiproject/groovy",files="settings.gradle[]"]
====

In this case, Gradle will look for a build file in the `app` directory.

We can view the structure of a multi-project build by running the `gradle projects` command:

----
$ gradle -q projects
include::{snippetsPath}/multiproject/basic-multiproject/tests/projects.out[]
----

In the example below, the `app` subproject is a Java application that applies the <<application_plugin#application_plugin,application plugin>> and configures the main class accordingly:

====
include::sample[dir="snippets/multiproject/basic-multiproject/kotlin",files="app/build.gradle.kts[]"]
include::sample[dir="snippets/multiproject/basic-multiproject/groovy",files="app/build.gradle[]"]
.app/src/main/java/com/example/Hello.java
[source, java]
----
include::{snippetsPath}/multiproject/basic-multiproject/groovy/app/src/main/java/com/example/Hello.java[]
----
====

We can then run the application by executing the `run` task from the <<application_plugin#application_plugin,application plugin>>.
----
$ gradle -q run
include::{snippetsPath}/multiproject/basic-multiproject/tests/run.out[]
----

[[sub:building_the_tree]]
== Building the tree

In the settings file, you can use the `include` method to build the project tree:

====
include::sample[dir="snippets/multiproject/standardLayouts/kotlin",files="settings.gradle.kts[tags=hierarchical-layout]"]
include::sample[dir="snippets/multiproject/standardLayouts/groovy",files="settings.gradle[tags=hierarchical-layout]"]
====

The `include` method takes <<intro_multi_project_builds#sec:project_path,project paths>> as arguments.
The project path is assumed to be equal to the relative physical file system path.
For example, a path `services:api` is mapped by default to a folder `./services/api` (relative to the project root `.`).

You only need to specify the leaves of the tree.
This means that including the path `services:hotels:api` will create 3 projects: `services`, `services:hotels`, and `services:hotels:api`.

More examples of how to work with the project path can be found in the DSL documentation of link:{groovyDslPath}++/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])++[Settings.include(java.lang.String[\])].

[[sec:adding_subprojects]]
== Adding subprojects

Let's add another subproject called `lib` to the previously created project.

All we need to do is add another `include` statement in the root settings file:
====
include::sample[dir="snippets/multiproject/multiple-subprojects/kotlin",files="settings.gradle.kts[]"]
include::sample[dir="snippets/multiproject/multiple-subprojects/groovy",files="settings.gradle[]"]
====

Gradle will then look for the build file of the new `lib` subproject in the `./lib/` subdirectory of the project:

[.multi-language-sample]
=====
[source, kotlin]
----
.
├── app
│   ...
│   └── build.gradle.kts
├── lib
│   ...
│   └── build.gradle.kts
└── settings.gradle.kts
----
=====
[.multi-language-sample]
=====
[source, groovy]
----
.
├── app
│   ...
│   └── build.gradle
├── lib
│   ...
│   └── build.gradle
└── settings.gradle
----
=====

[[sec:multibuild_buildSrc]]
== Common build logic

`buildSrc` is a Gradle recognized and protected directory for managing shared configuration among subprojects.

The `buildSrc` directory is located in the project root and contains custom plugins, shared dependencies and build logic.

It's ideal for keeping build scripts clean and keeping implementation separate from declaration.
It allows users to reuse tasks among subprojects.

You do not have to add an entry to the settings file in order for `buildSrc` to be recognized.
Instead, `buildSrc` is added to the classpath of `buildscript` so its contents are available in subproject build files in the same way as classpath dependencies: `buildscript { dependencies { classpath ... } }`

== Adding `buildSrc`

Let's add `buildSrc` to the previously created project and create common configuration under `buildSrc/src/main/kotlin` or `buildSrc/src/main/groovy`:

[.multi-language-sample]
=====
[source, kotlin]
----
.
├── app
│   ...
│   └── build.gradle.kts
├── lib
│   ...
│   └── build.gradle.kts
├── build-logic
│   ├── build.gradle.kts
│   └── src/main/kotlin/shared-build-configurations.gradle.kts
└── settings.gradle.kts
----
=====
[.multi-language-sample]
=====
[source, groovy]
----
.
├── app
│   ...
│   └── build.gradle
├── lib
│   ...
│   └── build.gradle
├── build-logic
│   ├── build.gradle
│   └── src/main/groovy/shared-build-configurations.gradle
└── settings.gradle
----
=====

Gradle automatically compiles and tests the code in `build-logic` and puts it in the classpath of your build script:

.build-logic/src/main/groovy/shared-build-configurations.gradle.kts
[source]
----
object Conventions {
    const val kotlinStdLib = "org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.21"
}
----

Which you can use accordingly:

.app/build.gradle.kts
[source]
----
dependencies {
    implementation(Conventions.kotlinStdLib)
}
----

[[sub:modifying_element_of_the_project_tree]]
== Modifying elements

The multi-project tree created in the settings file is made up of _project descriptors_.

You can modify these descriptors in the settings file at any time.

To access a descriptor you can:

====
include::sample[dir="snippets/multiproject/customLayout/kotlin",files="settings.gradle.kts[tags=lookup-project]"]
include::sample[dir="snippets/multiproject/customLayout/groovy",files="settings.gradle[tags=lookup-project]"]
====

Using this descriptor, you can change the name, project directory, and build file of a project:

====
include::sample[dir="snippets/multiproject/customLayout/kotlin",files="settings.gradle.kts[tags=change-project]"]
include::sample[dir="snippets/multiproject/customLayout/groovy",files="settings.gradle[tags=change-project]"]
====

Consult the link:{javadocPath}/org/gradle/api/initialization/ProjectDescriptor.html[ProjectDescriptor] class in the API documentation for more information.

[[sec:naming_recommendations]]
== Naming recommendations

As your project grows, naming and consistency get increasingly more important.
To keep your builds maintainable, we recommend the following:

1. *Keep default project names for subprojects*:
It is possible to configure custom project names in the settings file.
However, it’s an unnecessary extra effort for the developers to track which projects belong to what folders.

2. *Use kebab case formatting for all project names*:
A kebab case formatting is when all letters are lowercase, and words are separated with a dash (`-`) character (e.g., `kebab-case-formatting`).
This is already the de facto pattern for many large projects.
Gradle supports <<command_line_interface.adoc#sec:name_abbreviation,name abbreviation for kebab case names>>.

3. *Define the root project name in the settings file*:
The `rootProject.name` effectively assigns a name to the build, which is used in reports like build scans.
If the root project name is not set, the name will be the container directory name, which can be unstable (i.e., you can check out your project in any directory).
The name will be generated randomly if the root project name is not set and checked out to a file system's root (e.g., `/` or `C:\`).
