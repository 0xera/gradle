// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[custom_plugins]]
= Plugins

Gradle comes with a set of powerful core systems such as dependency management, task execution, and project configuration.
But everything on top is a plugin.

Plugins encapsulate logic for specific tasks or integrations, such as compiling code, running tests, or deploying artifacts.
By applying plugins, users can easily add new features to their build process without having to write complex code from scratch.

This plugin-based approach allows Gradle to be lightweight and modular.
It also promotes code reuse and maintainability, as plugins can be shared across projects or within an organization.

Plugins are typically sourced from Gradle or the Gradle community.
But when users want to organize their build logic or need specific build capabilities not provided by existing plugins, they can develop their own.

As such, we distinguish between three different kinds of plugins:

1. *Core Plugins* - plugins that come from Gradle.
2. *Community Plugins* - plugins that come from the public link:https://plugins.gradle.org/[Gradle Plugin Portal].
3. *Custom Plugins* - plugins that you develop yourself.

== Custom plugins

There are different types of *custom plugins*:

[cols="~,~,~,~,~"]
|===
|# |Type |Location: |Most likely: |Benefit:

|<<sec:build_script_plugins,1>>
|<<sec:build_script_plugins,Build script plugins>>
|Build script
|A local plugin
|Plugin is automatically compiled and included in the classpath of the build script.

|<<sec:precompile_script_plugin,2>>
|<<sec:precompile_script_plugin,Precompiled script plugins>>
|<<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>> folder
|A convention plugin
|Plugin is automatically compiled, tested, and available on the classpath of the build script. The plugin is visible to every build script used by the build.

|<<sec:custom_plugins_standalone_project,3>>
|<<sec:custom_plugins_standalone_project,Binary plugins>>
|Standalone project
|A shared plugin
|Produces and publishes a JAR which you can then use in multiple builds and share with others.
|===

[[sec:build_script_plugins]]
== 1. Build script plugins

To create a Gradle plugin, you need to write a class that implements the link:{javadocPath}/org/gradle/api/Plugin.html[Plugin] interface.

NOTE: The link:{javadocPath}/org/gradle/api/Plugin.html[Plugin] class is a generic type.

When the plugin is applied to a project, Gradle creates an instance of the plugin class and calls the instance's link:{javadocPath}/org/gradle/api/Plugin.html#apply-T-[Plugin.apply()] method.
The `Project` object is passed as a parameter, which the plugin can use to configure the project however it needs to.

[[sec:writing_a_simple_plugin]]
The following sample creates a `Greeting` plugin, which adds a `hello` task to a project:

====
include::sample[dir="snippets/customPlugins/customPlugin/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/customPlugins/customPlugin/groovy",files="build.gradle[]"]
====

----
$ gradle -q hello
include::{snippetsPath}/customPlugins/customPlugin/tests/customPlugin.out[]
----

NOTE: A new instance of a `Plugin` is created for each project it is applied to.

In the example, the plugin accepts the link:{groovyDslPath}/org.gradle.api.Project.html[Project] type as a type parameter.
Alternatively, the plugin can accept a parameter of type link:{groovyDslPath}/org.gradle.api.initialization.Settings.html[Settings] to be applied in a settings script, or a parameter of type link:{groovyDslPath}/org.gradle.api.invocation.Gradle.html[Gradle] to be applied in an initialization script.

[[sec:precompile_script_plugin]]
== 2. Precompiled script plugins

Precompiled script plugins are compiled into class files and packaged into a JAR before they are executed.

To create a precompiled script plugin, you typically use the <<java_gradle_plugin#java_gradle_plugin,Gradle Plugin Development Plugin>>.
This plugin provides the necessary tasks and configurations (including the plugin metadata) to compile your script into a plugin that can be applied in other builds.

To apply a precompiled script plugin, you need to know its ID.
The ID is derived from the plugin script's filename and its (optional) package declaration.

For example, the script `src/main/\*/java-library-convention.gradle(.kts)` has a plugin ID of `java-library-convention` (assuming it has no package declaration).
Likewise, `src/main/\*/my/java-library-convention.gradle(.kts)` has a plugin ID of `my.java-library-convention` as long as it has a package declaration of `my`.

Precompiled script plugin names have two important limitations:

* They cannot start with `org.gradle`.
* They cannot have the same name as a core plugin.

This ensures that the precompiled script plugins won't be silently ignored.

Let's take an example build with three subprojects: one for `data-model`, one for `business-logic` and one for `app` code.
The project has the following structure:

[source, text]
----
.
├── buildSrc
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── data-model
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── business-logic
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── app
│   ├── src
│   │   └──...
│   └── build.gradle.kts
└── settings.gradle.kts
----

The build file of the `business-logic` subproject is as follows:

[source,kotlin]
.business-logic/build.gradle.kts
----
plugins {
    id("java-library")
    id("org.jetbrains.kotlin.jvm")
}

java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(17))
}

tasks.test {
    useJUnitPlatform()
}

kotlin {
    jvmToolchain(17)
}
----

We apply the `java-library` plugin and add the `org.jetbrains.kotlin.jvm` plugin for Kotlin support.
We also configure Kotlin, Java, tests and more.

Our build file is beginning to grow.

The more plugins we apply and the more plugins we configure, the larger it gets.
There's also repetition in the build files of the `app` and `data-model` subprojects, especially for common configurations like the Java version and Kotlin support.

To address this, we use *convention plugins*.
This allows us to avoid repeating configuration in each build file and keep our build scripts more concise and maintainable.

=== Convention Plugins

In *convention plugins*, we can encapsulate arbitrary build configuration or custom build logic.

To develop a convention plugin, we use <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>> – which represents a completely separate Gradle build.

`buildSrc` has its own settings file to define where dependencies of this build are located.
In our case, we want to have access to community plugins, so we add the Gradle Plugin Portal as a repository:

[source,kotlin]
.settings.gradle.kts
----
dependencyResolutionManagement {
    repositories.gradlePluginPortal()
}
----

We also define one subproject that we will use to define our convention plugin called `java-plugin`.
In the subproject, we create a build file and apply the link:https://plugins.gradle.org/plugin/org.gradle.kotlin.kotlin-dsl[`kotlin-dsl`] plugin:

[source,kotlin]
.buildSrc/java-plugin/build.gradle.kts
----
plugins {
    `kotlin-dsl`
}
----

Because we want to use the Kotlin plugin, an external plugin, we need to <<sec:applying_external_plugins,define a dependency in the build file>>:

[source,kotlin]
.buildSrc/java-plugin/build.gradle.kts
----
plugins {
    `kotlin-dsl`
}

dependencies {
    implementation("org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.20")
}
----

We add a script called `my-java-library.gradle.kts` inside the `src/main/kotlin` and we put all the plugin application and configuration that we defined in our `business-logic` into it:

[source,kotlin]
.buildSrc/java-plugin/src/main/kotlin/my-java-library.gradle.kts
----
plugins {
    id("java-library")
    id("org.jetbrains.kotlin.jvm")
}

java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(17))
}

tasks.test {
    useJUnitPlatform()
}

kotlin {
    // ...
}
----

The name of the file `my-java-library` is the ID of our brand new plugin, which we can now use in all of our subprojects.

The `business-logic` build file becomes much simpler by applying our convention `my-java-library` plugin:

[source,kotlin]
.business-logic/build.gradle.kts
----
plugins {
    id("my-java-library")
}
----

This convention plugin enables us to easily share common configurations across all our build files.
Any modifications can be made in one place, simplifying maintenance.

[[sec:applying_external_plugins]]
=== Applying external plugins in precompiled script plugins

In order to apply an external plugin in a precompiled script plugin, it has to be added to the plugin project's implementation classpath in the plugin's build file:

====
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/kotlin",files="buildSrc/build.gradle.kts[]"]
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/groovy",files="buildSrc/build.gradle[]"]
====

It can then be applied in the precompiled script plugin:
====
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/kotlin",files="buildSrc/src/main/kotlin/my-plugin.gradle.kts[]"]
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/groovy",files="buildSrc/src/main/groovy/my-plugin.gradle[]"]
====

The plugin version in this case is defined in the dependency declaration.

[[sec:custom_plugins_standalone_project]]
== 3. Binary plugins

Let's move our <<sec:build_script_plugins,build script>> plugin to a standalone project so that we can publish it and share it with others.

This project is simply a Java project that produces a JAR containing the plugin classes.

The easiest way to package and publish a plugin is to use the <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin Development Plugin>>.

Here is a simple build script for the project:

====
include::sample[dir="snippets/plugins/customPlugin/kotlin/java-gradle-plugin",files="build.gradle.kts[tags=use-and-configure-plugin]"]
include::sample[dir="snippets/plugins/customPlugin/groovy/java-gradle-plugin",files="build.gradle[tags=use-and-configure-plugin]"]
====

For more on publishing plugins, see <<publishing_gradle_plugins.adoc#plugin-publishing-plugin,Publishing Plugins>>.
