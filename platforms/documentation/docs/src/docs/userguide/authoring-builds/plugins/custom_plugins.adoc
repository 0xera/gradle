// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[custom_plugins]]
= Plugins

Gradle comes with a set of powerful core systems.
But everything on top is a plugin.

A Gradle plugin packages up reusable pieces of build logic, which can be used across many different projects and builds.

Gradle allows you to implement your own plugins, so you can reuse your build logic, and share it with others.

We can distinguish between three different kinds of plugins:

1. *Core Plugins* - plugins that come from Gradle and are applied by a simple ID such as `java-library`.
2. *Community Plugins* - public plugins that come from the Gradle Plugin Portal and are applied by an ID and a version such as `id("org.jetbrains.intellij") version "1.17.2"`.
3. *Convention Plugins* - plugins that you write yourself.

Plugins can reside in three places:

[cols="~,~,~,~,~"]
|===
|# |Name |Location: |Most likely: |Benefit:

|<<sec:build_script_plugins,1>>
|<<sec:build_script_plugins,Build script plugins>>
|Build script
|A small local plugin
|Plugin is automatically compiled and included in the classpath of the build script.

|<<sec:precompile_script_plugin,2>>
|<<sec:precompile_script_plugin,Precompiled script plugins>>
|<<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>> folder
|A convention plugin
|Plugin is automatically compiled, tested, and available on the classpath of the build script. The plugin is visible to every build script used by the build.

|<<sec:custom_plugins_standalone_project,3>>
|<<sec:custom_plugins_standalone_project,Binary plugins>>
|Standalone project
|A community plugin
|Produces and publishes a JAR which you can then use in multiple builds and share with others.
|===

[[sec:build_script_plugins]]
== 1. Build script plugins

To create a Gradle plugin, you need to write a class that implements the link:{javadocPath}/org/gradle/api/Plugin.html[Plugin] interface.

When the plugin is applied to a project, Gradle creates an instance of the plugin class and calls the instance's link:{javadocPath}/org/gradle/api/Plugin.html#apply-T-[Plugin.apply()] method.

The project object is passed as a parameter, which the plugin can use to configure the project however it needs to.

[[sec:writing_a_simple_plugin]]
The following sample contains a greeting plugin, which adds a `hello` task to the project:

====
include::sample[dir="snippets/customPlugins/customPlugin/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/customPlugins/customPlugin/groovy",files="build.gradle[]"]
====

----
$ gradle -q hello
include::{snippetsPath}/customPlugins/customPlugin/tests/customPlugin.out[]
----

The link:{javadocPath}/org/gradle/api/Plugin.html[Plugin] class is a generic type.

In the example, the plugin accepts the link:{groovyDslPath}/org.gradle.api.Project.html[Project] type as a type parameter.
Alternatively, the plugin can accept a parameter of type link:{groovyDslPath}/org.gradle.api.initialization.Settings.html[Settings] to be applied in a settings script, or a parameter of type link:{groovyDslPath}/org.gradle.api.invocation.Gradle.html[Gradle] to be applied in an initialization script.

NOTE: A new instance of a plugin is created for each project it is applied to.

[[sec:precompile_script_plugin]]
== 2. Precompiled script plugins

Gradle also allows you to provide build logic written in either Groovy or Kotlin DSLs as precompiled script plugins.
You write these as `\*.gradle` files in `src/main/groovy` directory or `*.gradle.kts` files in `src/main/kotlin` directory.

Precompiled script plugins are compiled into class files and packaged into a JAR.
The plugin metadata for them is generated using the <<java_gradle_plugin#java_gradle_plugin,Gradle Plugin Development Plugin>>.

Precompiled script plugin names have two important limitations:

* They cannot start with `org.gradle`.
* They cannot have the same name as a built-in plugin id.

This ensures that the precompiled script plugins won't be silently ignored.

[.multi-language-text.lang-kotlin]
To apply a precompiled script plugin, you need to know its ID which is derived from the plugin script's filename (minus the `.gradle.kts` extension) and its (optional) package declaration.

[.multi-language-text.lang-groovy]
To apply a precompiled script plugin, you need to know its ID which is derived from the plugin script's filename (minus the `.gradle` extension).

[.multi-language-text.lang-kotlin]
For example, the script `src/main/kotlin/java-library-convention.gradle.kts` would have a plugin ID of `java-library-convention` (assuming it has no package declaration).
Likewise, `src/main/kotlin/my/java-library-convention.gradle.kts` would result in a plugin ID of `my.java-library-convention` as long as it has a package declaration of `my`.

[.multi-language-text.lang-groovy]
For example, the script `src/main/groovy/java-library-convention.gradle` would have a plugin ID of `java-library-convention`.
Likewise, `src/main/groovy/my.java-library-convention.gradle` would result in a plugin ID of `my.java-library-convention`.

Let's take an example project with three subprojects: one for `data-model`, one for `business-logic` and one for `app` code.

[source, text]
----
.
├── buildSrc
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── data-model
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── business-logic
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── app
│   ├── src
│   │   └──...
│   └── build.gradle.kts
└── settings.gradle.kts
----

Let's look at the build file of our `business-logic` subproject:

[source,kotlin]
.business-logic/build.gradle.kts
----
plugins {
    id("java-library")
    id("org.jetbrains.kotlin.jvm")
}

java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(17))
}

tasks.test {
    useJUnitPlatform()
}

kotlin {
    jvmToolchain(17)
}
----

We apply the `java-library` plugin and add the `org.jetbrains.kotlin.jvm` plugin for Kotlin support.
We also configure kotlin, java, tests and more.
Our build file is beginning to grow.
The more plugins we apply and the more plugins we configure, the larger it gets.

There's also repetition in the build files of our subprojects `app` and `data-model`, especially for common configurations like Java version and Kotlin support.

To address this, we use convention plugins.
This allows us to avoid repeating configuration in each build file and keep our build scripts more concise and maintainable.

=== Convention Plugins

In convention plugins, we can encapsulate arbitrary build configuration or custom build logic.

To develop a convention plugin, we use <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>> – which represents a completely separate Gradle build.

`buildSrc` has its own settings file to define where dependencies of this build are located.
In our case, we want to have access to community plugins, so we add the Gradle Plugin Portal as a repository:

[source,kotlin]
.settings.gradle.kts
----
dependencyResolutionManagement {
    repositories.gradlePluginPortal()
}
----

We also define one subproject that we will use to define our convention plugins called `java-plugin`.
In the subproject, we create a build file and apply the link:https://plugins.gradle.org/plugin/org.gradle.kotlin.kotlin-dsl[`kotlin-dsl` plugin]:

[source,kotlin]
.buildSrc/java-plugin/build.gradle.kts
----
plugins {
    `kotlin-dsl`
}
----

`kotlin-dsl` is Gradle core plugin specifically designed to write plugins in the Kotlin DSL.
There is an equivalent, if you want to use the Groovy DSL.

Because we want to use the Kotlin plugin, an external plugin, we need to <<sec:applying_external_plugins,define a dependency in the build file>>:

[source,kotlin]
.buildSrc/java-plugin/build.gradle.kts
----
plugins {
    `kotlin-dsl`
}

dependencies {
    implementation("org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.20")
}
----

Now, as the `kotlin-dsl` plugin was applied, we can write Gradle scripts inside the `src/main/kotlin` folder.

We add a script called `my-java-library.gradle.kts` and we just put all the plugin application and configuration that we defined in our build file previously, into this convention plugin:

[source,kotlin]
.buildSrc/java-plugin/src/main/kotlin/my-java-library.gradle.kts
----
plugins {
    id("java-library")
    id("org.jetbrains.kotlin.jvm")
}

java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(17))
}

tasks.test {
    useJUnitPlatform()
}

kotlin {
    // ...
}
----

The name of the file `my-java-library` is the ID of the plugin, which we can now use in all of our subprojects.

We can change all of our subprojects' build files to apply our convention `my-java-library` plugin:

[source,kotlin]
.business-logic/build.gradle.kts
----
plugins {
    id("my-java-library")
}
----

And now, we automatically share all the common configuration in our build files and can change it in one single point.

[[sec:applying_external_plugins]]
=== Applying external plugins in precompiled script plugins

In order to apply an external plugin in a precompiled script plugin, it has to be added to the plugin project's implementation classpath in the plugin's build file:

====
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/kotlin",files="buildSrc/build.gradle.kts[]"]
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/groovy",files="buildSrc/build.gradle[]"]
====

It can then be applied in the precompiled script plugin:
====
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/kotlin",files="buildSrc/src/main/kotlin/my-plugin.gradle.kts[]"]
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/groovy",files="buildSrc/src/main/groovy/my-plugin.gradle[]"]
====

The plugin version in this case is defined in the dependency declaration.

[[sec:custom_plugins_standalone_project]]
== 3. Binary plugins

Let's move our <<sec:build_script_plugins,build script>> plugin to a standalone project so that we can publish it and share it with others.

This project is simply a Java project that produces a JAR containing the plugin classes.

The easiest and the recommended way to package and publish a plugin is to use the <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin Development Plugin>>.
This plugin will automatically apply the <<java_plugin.adoc#java_plugin,Java Plugin>>, add the `gradleApi()` dependency to the api configuration, generate the required plugin descriptors in the resulting JAR file and configure the <<plugins.adoc#sec:plugin_markers,Plugin Marker Artifact>> to be used when publishing.

Here is a simple build script for the project:

====
include::sample[dir="snippets/plugins/customPlugin/kotlin/java-gradle-plugin",files="build.gradle.kts[tags=use-and-configure-plugin]"]
include::sample[dir="snippets/plugins/customPlugin/groovy/java-gradle-plugin",files="build.gradle[tags=use-and-configure-plugin]"]
====

For more on publishing plugins, see <<publishing_gradle_plugins.adoc#plugin-publishing-plugin,Publishing Plugins>>.
