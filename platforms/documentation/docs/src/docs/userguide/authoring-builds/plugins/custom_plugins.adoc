// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[custom_plugins]]
= Understanding Plugins

Gradle comes with a set of powerful core systems such as dependency management, task execution, and project configuration.
But everything on top is a plugin.

Plugins encapsulate logic for specific tasks or integrations, such as compiling code, running tests, or deploying artifacts.
By applying plugins, users can easily add new features to their build process without having to write complex code from scratch.

This plugin-based approach allows Gradle to be lightweight and modular.
It also promotes code reuse and maintainability, as plugins can be shared across projects or within an organization.

Before reading this chapter, it's recommended to have read the <<gradle_directories.adoc#gradle_directories,Learning The Basics>> and completed the <<partr1_gradle_init.adoc#partr1_gradle_init,Tutorial>>.

== Plugins Introduction

Plugins are typically sourced from Gradle or the Gradle community.
But when users want to organize their build logic or need specific build capabilities not provided by existing plugins, they can develop their own.

As such, we distinguish between three different kinds of plugins:

1. *Core Plugins* - plugins that come from Gradle.
2. *Community Plugins* - plugins that come from link:https://plugins.gradle.org/[Gradle Plugin Portal] or a public repository.
3. *Local or Custom Plugins* - plugins that you develop yourself.

=== Core Plugins
The term *core plugin* refers to a plugin that is part of the Gradle distribution such as `id("java-library")`.
It is always available.

=== Community Plugins
The term *community plugin* refers to a plugin published to the Gradle Plugin Portal (or another public repository) such as `id("com.diffplug.spotless") version "6.25.0"`.
In order for Gradle to find the plugin, you must declare the repository that provides the plugin.
For example, `gradlePluginPortal()`.

=== Local or Custom Plugins
The term *local or custom plugin* refers to a plugin you write yourself for your own build as an `includedBuild` or in `buildSrc`.
For example `includeBuild("gradle-build-logic")`.

== Custom plugins

There are three types of *custom plugins*:

[cols="~,~,~,~,~"]
|===
|# |Type |Location: |Most likely: |Benefit:

|<<sec:build_script_plugins,1>>
|<<sec:build_script_plugins,Build script plugins>>
|Build script
|A local plugin
|Plugin is automatically compiled and included in the classpath of the build script.

|<<sec:precompile_script_plugin,2>>
|<<sec:precompile_script_plugin,Precompiled script plugins>>
|<<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>> folder
|A convention plugin
|Plugin is automatically compiled, tested, and available on the classpath of the build script. The plugin is visible to every build script used by the build.

|<<sec:custom_plugins_standalone_project,3>>
|<<sec:custom_plugins_standalone_project,Binary plugins>>
|Standalone project
|A shared plugin
|Plugin JAR is produced and published. The plugin can be used in multiple builds and shared with others.
|===

[[sec:build_script_plugins]]
== Build script plugins

*Build script plugins* are typically small, local plugins written in build files for tasks specific to a single build or project and do not need to be reused across multiple projects.

To create a Gradle plugin, you need to write a class that implements the link:{javadocPath}/org/gradle/api/Plugin.html[Plugin] interface in one of your build files.

NOTE: The link:{javadocPath}/org/gradle/api/Plugin.html[Plugin] class is a generic type.

The `Project` object is passed as a parameter, which the plugin can use to configure the project however it needs to.

[[sec:writing_a_simple_plugin]]
The following sample creates a `GreetingPlugin`, which adds a `hello` task to a project:

====
include::sample[dir="snippets/customPlugins/customPlugin/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/customPlugins/customPlugin/groovy",files="build.gradle[]"]
====

----
$ gradle -q hello
include::{snippetsPath}/customPlugins/customPlugin/tests/customPlugin.out[]
----

[[sec:precompile_script_plugin]]
== Precompiled script plugins

*Precompiled script plugins* are compiled into class files and packaged into a JAR before they are executed.
They are best used as *convention plugins* that share build logic across projects or as a way to neatly organize build logic.

To create a precompiled script plugin, you can:

1. Use Gradle's Kotlin DSL - The plugin is a `.gradle.kts` file, and apply `id("kotlin-dsl")`.
2. Use Gradle's Groovy DSL - The plugin is a `.gradle` file, and apply `id("groovy-gradle-plugin")`.
3. Write a Java, Scala, Kotlin, or Groovy class - The plugin is an abstract class that implements the `Plugin<Project>` interface, and apply `id("java-gradle-plugin")`.

To apply a precompiled script plugin, you need to know its ID.
The ID is derived from the plugin script's filename and its (optional) package declaration.

For example, the script `src/main/\*/java-library-convention.gradle(.kts)` has a plugin ID of `java-library-convention` (assuming it has no package declaration).
Likewise, `src/main/\*/my/java-library-convention.gradle(.kts)` has a plugin ID of `my.java-library-convention` as long as it has a package declaration of `my`.

Precompiled script plugin names have two important limitations:

* They cannot start with `org.gradle`.
* They cannot have the same name as a core plugin.

This ensures that the precompiled script plugins won't be silently ignored.

When the plugin is applied to a project, Gradle creates an instance of the plugin class and calls the instance's link:{javadocPath}/org/gradle/api/Plugin.html#apply-T-[Plugin.apply()] method.

NOTE: A new instance of a `Plugin` is created for each project it is applied to.

Let's update the `GreetingPlugin` script plugin to a precompiled script plugin:

====
[.multi-language-sample]
=====
./buildSrc/src/main/groovy/com/example/GreetingPlugin.gradle.kts
[source,kotlin]
----
package com.example

import org.gradle.api.Plugin
import org.gradle.api.Project

class GreetingPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        project.task("hello") {
            doLast {
                println("Hello from the GreetingPlugin")
            }
        }
    }
}
----
=====
[.multi-language-sample]
=====
./buildSrc/src/main/groovy/com/example/GreetingPlugin.gradle
[source,groovy]
----
package com.example

import org.gradle.api.Plugin
import org.gradle.api.Project

class GreetingPlugin implements Plugin<Project> {
    void apply(Project project) {
        project.task('hello') {
            doLast {
                println 'Hello from the GreetingPlugin'
            }
        }
    }
}
----
=====
====

The `GreetingPlugin` can now be applied in other build files using its `com.example.GreetingPlugin` ID:

====
[.multi-language-sample]
=====
./subproject/build.gradle.kts
[source,kotlin]
----
plugins {
    id("com.example.GreetingPlugin")
}
----
=====
[.multi-language-sample]
=====
./subproject/build.gradle
[source,groovy]
----
plugins {
    id("com.example.GreetingPlugin")
}
----
=====
====

[[sec:convention_plugins]]
== Convention Plugins

A *convention plugin* is a plugin that configures existing core and community plugins with your own conventions (i.e. default values) such as setting the Java version by using `java.toolchain.languageVersion.set(JavaLanguageVersion.of(17))`.
This term is used to distinguish plugins that configure existing functionality from those that add new functionality.

Let's take an example build with three subprojects: one for `data-model`, one for `business-logic` and one for `app` code.
The project has the following structure:

[source, text]
----
.
├── buildSrc
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── data-model
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── business-logic
│   ├── src
│   │   └──...
│   └── build.gradle.kts
├── app
│   ├── src
│   │   └──...
│   └── build.gradle.kts
└── settings.gradle.kts
----

The build file of the `business-logic` subproject is as follows:

[source,kotlin]
.business-logic/build.gradle.kts
----
plugins {
    id("java-library")
    id("org.jetbrains.kotlin.jvm")
}

java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(17))
}

tasks.test {
    useJUnitPlatform()
}

kotlin {
    jvmToolchain(17)
}
----

We apply the `java-library` plugin and add the `org.jetbrains.kotlin.jvm` plugin for Kotlin support.
We also configure Kotlin, Java, tests and more.

Our build file is beginning to grow...

The more plugins we apply and the more plugins we configure, the larger it gets.
There's also repetition in the build files of the `app` and `data-model` subprojects, especially for common configurations like the Java version and Kotlin support.

To address this, we use convention plugins.
This allows us to avoid repeating configuration in each build file and keeps our build scripts more concise and maintainable.
In convention plugins, we can encapsulate arbitrary build configuration or custom build logic.

To develop a convention plugin, we recommend using <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>> – which represents a completely separate Gradle build.
`buildSrc` has its own settings file to define where dependencies of this build are located.
In our case, we want to have access to community plugins, so we add the Gradle Plugin Portal as a repository:

[source,kotlin]
.buildSrc/settings.gradle.kts
----
dependencyResolutionManagement {
    repositories.gradlePluginPortal()
}
----

We also define one subproject that we will use to define our convention plugin called `java-plugin`:

[source,kotlin]
.buildSrc/settings.gradle.kts
----
dependencyResolutionManagement {
    repositories.gradlePluginPortal()
}

include("java-plugin")
----

In the subproject, we create a build file and apply the link:https://plugins.gradle.org/plugin/org.gradle.kotlin.kotlin-dsl[`kotlin-dsl`] plugin:

[source,kotlin]
.buildSrc/java-plugin/build.gradle.kts
----
plugins {
    `kotlin-dsl`
}
----

Because we want to use the Kotlin plugin, an external plugin, we need to <<sec:applying_external_plugins,define a dependency in the build file>>:

[source,kotlin]
.buildSrc/java-plugin/build.gradle.kts
----
plugins {
    `kotlin-dsl`
}

dependencies {
    implementation("org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.20")
}
----

We add a script called `my-java-library.gradle.kts` inside the `java-plugin/src/main/kotlin` and we put all the plugin application and configuration that we defined in our `business-logic` into it:

[source,kotlin]
.buildSrc/java-plugin/src/main/kotlin/my-java-library.gradle.kts
----
plugins {
    id("java-library")
    id("org.jetbrains.kotlin.jvm")
}

java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(17))
}

tasks.test {
    useJUnitPlatform()
}

kotlin {
    // ...
}
----

The name of the file `my-java-library` is the ID of our brand-new plugin, which we can now use in all of our subprojects.

The `business-logic` build file becomes much simpler by removing all the redundant build logic and applying our convention `my-java-library` plugin instead:

[source,kotlin]
.business-logic/build.gradle.kts
----
plugins {
    id("my-java-library")
}
----

This convention plugin enables us to easily share common configurations across all our build files.
Any modifications can be made in one place, simplifying maintenance.

[[sec:applying_external_plugins]]
=== Applying external plugins in precompiled script plugins

In order to apply an external plugin in a precompiled script plugin, it has to be added to the plugin project's implementation classpath in the plugin's build file:

====
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/kotlin",files="buildSrc/build.gradle.kts[]"]
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/groovy",files="buildSrc/build.gradle[]"]
====

It can then be applied in the precompiled script plugin:
====
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/kotlin",files="buildSrc/src/main/kotlin/my-plugin.gradle.kts[]"]
include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/groovy",files="buildSrc/src/main/groovy/my-plugin.gradle[]"]
====

The plugin version in this case is defined in the dependency declaration.

[[sec:custom_plugins_standalone_project]]
== Binary plugins

*Binary plugins* in Gradle are plugins that are built as standalone JAR files and applied to a project using the `plugins{}` block in the build script.

Let's move our `GreetingPlugin` to a standalone project so that we can publish it and share it with others.
The plugin is essentially moved from the `buildSrc` folder to its own build called `greeting-plugin`.

NOTE: You can publish the plugin from `buildSrc`, but this is not recommended practice. Plugins that are ready for publication should be in their own build.

`greeting-plugin` is simply a Java project that produces a JAR containing the plugin classes.

The easiest way to package and publish a plugin to a repository is to use the <<java_gradle_plugin.adoc#java_gradle_plugin,Gradle Plugin Development Plugin>>.
This plugin provides the necessary tasks and configurations (including the plugin metadata) to compile your script into a plugin that can be applied in other builds.

Here is a simple build script for the `greeting-plugin` project using the Gradle Plugin Development Plugin:

====
include::sample[dir="snippets/plugins/customPlugin/kotlin/java-gradle-plugin",files="build.gradle.kts[tags=use-and-configure-plugin]"]
include::sample[dir="snippets/plugins/customPlugin/groovy/java-gradle-plugin",files="build.gradle[tags=use-and-configure-plugin]"]
====

For more on publishing plugins, see <<publishing_gradle_plugins.adoc#plugin-publishing-plugin,Publishing Plugins>>.

==  Project vs Settings vs Init plugins

In the example used through this section, the plugin accepts the link:{groovyDslPath}/org.gradle.api.Project.html[Project] type as a type parameter.
Alternatively, the plugin can accept a parameter of type link:{groovyDslPath}/org.gradle.api.initialization.Settings.html[Settings] to be applied in a settings script, or a parameter of type link:{groovyDslPath}/org.gradle.api.invocation.Gradle.html[Gradle] to be applied in an initialization script.

The difference between these types of plugins lies in the scope of their application:

Project Plugin :: A project plugin is a plugin that is applied to a specific project in a multi-project build.
It can customize the build logic, add tasks, and configure the project-specific settings.

Settings Plugin :: A settings plugin is a plugin that is applied to the `settings.gradle` or `settings.gradle.kts` file.
It can configure settings that apply to the entire build, such as defining which projects are included in the build, configuring build script repositories, and applying common configurations to all projects.

Init Plugin :: An init plugin is a plugin that is applied to the `init.gradle` or `init.gradle.kts` file.
It can configure settings that apply globally to all Gradle builds on a machine, such as configuring the Gradle version, setting up default repositories, or applying common plugins to all builds.
