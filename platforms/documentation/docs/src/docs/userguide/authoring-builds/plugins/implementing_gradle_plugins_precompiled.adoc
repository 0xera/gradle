// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[implemention_precompiled_plugins]]
= Implementing Pre-compiled Script Plugins

A *precompiled script plugin* is typically a Kotlin script that has been compiled and distributed as Java class files packaged in a library.
These scripts are intended to be consumed as binary Gradle plugins or as convention plugins.

[[sec:the_plugin_id]]
== The plugin ID

The plugin ID for a precompiled script is derived from its name and optional package declaration.

For example, a script named `code-quality.gradle(.kts)` located in `src/main/groovy` (or `src/main/kotlin`) without a package declaration would be exposed as the `code-quality` plugin:

[source,kotlin]
----
plugins {
    id("code-quality")
}
----

On the other hand, a script named `code-quality.gradle(.kts)` located in `src/main/groovy/my` (or `src/main/kotlin/my`) with the package declaration `my` would be exposed as the `my.code-quality` plugin:

[source,kotlin]
----
plugins {
    id("my.code-quality")
}
----

[[sec:working_with_files_in_custom_tasks_and_plugins]]
== Working with files

You should use Gradle's <<custom_gradle_types.adoc#managed_properties,managed properties>> and `project.layout` to select file or directory locations.
This will enable <<lazy_configuration.adoc,lazy configuration>> so that the actual location will only be resolved when the file is needed and can be reconfigured at any time during build configuration.
For example:

.buildSrc/packaging/src/main/kotlin/greetings.gradle.kts
[source,kotlin]
----
// Create a variable for the greeting using Gradle managed properties
val message: Property<String> = null

// Print and find the greeting in a txt file using project.layout
println("Hello, ${file(project.layout.buildDirectory.file("defaultGreeting.txt")).readText()}")
----

You can find out more about working with files lazily in <<working_with_files.adoc#working_with_files,Working with Files>>.

[[sec:getting_input_from_the_build]]
== Making a plugin configurable

*xtension objects* are commonly used in plugins to expose configuration options and additional functionality to build scripts.

When you apply a plugin that defines an extension, you can access the extension object and configure its properties or call its methods to customize the behavior of the plugin or tasks provided by the plugin.

A link:{groovyDslPath}/org.gradle.api.Project.html[Project] has an associated link:{javadocPath}/org/gradle/api/plugins/ExtensionContainer.html[ExtensionContainer] object that contains all the settings and properties for the plugins that have been applied to the project.
You can provide configuration for your plugin by adding an extension object to this container.

Let's update our example:

.buildSrc/packaging/src/main/kotlin/greetings.gradle.kts
[source,kotlin]
----
interface GreetingPluginExtension {
    val message: Property<String>
}

println("Hello, ${file(project.layout.buildDirectory.file("defaultGreeting.txt")).readText()}")

// Add the 'greeting' extension object
val extension = project.extensions.create<GreetingPluginExtension>("greeting")
----

You can set the value of the `message` property directly with `extension.message.set("Hi from Gradle,")`.

However, the `GreetingPluginExtension` object becomes available as a project property with the same name as the extension object.
You can now access `message` like so:

[source,kotlin]
----
the<GreetingPluginExtension>().message.set("Hi from Gradle") // Where the<GreetingPluginExtension>() is equivalent to project.extensions.getByType(GreetingPluginExtension::class.java)
----

You can find out more about implementing project extensions in <<custom_gradle_types.adoc#custom_gradle_types,Developing Custom Gradle Types>>.

[[sec:plugin_conventions]]
== Conventions

In plugins, you can define default values, also known as *conventions*, using the `project` object.

Convention properties are properties that are initialized with default values but can be overridden:

.buildSrc/packaging/src/main/kotlin/greetings.gradle.kts
[source,kotlin]
----
interface GreetingPluginExtension {
    val message: Property<String>
}

val extension = project.extensions.create<GreetingPluginExtension>("greeting")

// Set a default value for 'message'
extension.message.convention(project.layout.buildDirectory.file("defaultGreeting.txt").get().asFile.readText())
----

`extension.message.convention(...)` sets a convention for the `message` property of the extension.
This convention specifies that the value of `message` should default to the content of a file named `defaultGreeting.txt` located in the build directory of the project.

If the `message` property is not explicitly set, its value will be automatically set to the content of `defaultGreeting.txt`.

[[sec:mapping_extension_properties_to_task_properties]]
== Mapping extension properties to task properties

Using an extension and mapping it to a custom task's input/output properties is common in plugins.

In this example, the message property of the `GreetingPluginExtension` is mapped to the message property of the `GreetingTask` as an input:

.buildSrc/packaging/src/main/kotlin/greetings.gradle.kts
[source,kotlin]
----
interface GreetingPluginExtension {
    val message: Property<String>
}

val extension = project.extensions.create<GreetingPluginExtension>("greeting")

// Create a greeting task
class GreetingTask : DefaultTask() {
    @Input
    val message = project.objects.property<String>()

    @TaskAction
    fun greet() {
        println("Message: ${message.get()}")
    }
}

// Register the task and set the convention
tasks.register<GreetingTask>("hello") {
    message.convention(extension.message)
}
----

This means that changes to the extension's `message` property will trigger the task to be considered out-of-date, ensuring that the task is re-executed with the new message.

You can find out more about types that you can use in task implementations and extensions in <<lazy_configuration.adoc#lazy_configuration,Lazy Configuration>>.
