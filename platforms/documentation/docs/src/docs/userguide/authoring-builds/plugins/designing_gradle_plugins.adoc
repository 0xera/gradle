// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

= Designing Plugins

It is important to design Gradle plugins based on established practices.

If you suspect issues with your plugin code, try creating a link:https://scans.gradle.com/[Build Scan] to identify bottlenecks.
The link:https://github.com/gradle/gradle-profiler[Gradle profiler] can help automate Build Scan generation and gather more low-level information.

== Use binary plugins

Gradle distinguishes between two types of plugins: <<plugins.adoc#sec:types_of_plugins,script plugins>> and <<plugins.adoc#sec:types_of_plugins,binary plugins>>.

<<plugins.adoc#sec:script_plugins,Script plugins>> are hard to maintain, test, and do not support defining new reusable types.

<<plugins.adoc#sec:binary_plugins,Binary plugins>> should be used when logic needs to be shared across independent projects.
They allow for structuring code into classes and packages, are cacheable, support versioning, and are easily testable.

== Consider the impact on performance

When designing Gradle plugins, be mindful of the impact on end users.
Simple logic can significantly affect build performance, especially when executed during the <<build_lifecycle.adoc#sec:build_phases,configuration phase>>.
Consider moving such logic to the execution phase if possible.

== Provide convention and configuration

Gradle plugins should provide sensible defaults and standards (i.e., conventions) in a specific context, reducing the number of decisions users need to make.
Users can easily configure these conventions if needed, maintaining flexibility.

For example, the <<java_plugin.adoc#java_plugin,Java plugin>> defines the `src/main/java` directory as the default source directory for compilation.
Unless users prefer other standards, no additional configuration is needed.

Let’s have a look at an example for conventions introduced by a plugin.
The plugin retrieves information from a server by making HTTP calls.
The default URL used by the plugin is configured to point to a server within an organization developing the plugin: +++https://www.myorg.com/server+++.
A good way to make the default URL configurable is to use an <<custom_plugins.adoc#sec:getting_input_from_the_build,extension>>.
An extension exposes a custom DSL for capturing user input that influences the runtime behavior.

The following example shows such a custom DSL:

====
include::sample[dir="snippets/developingPlugins/conventionOverConfiguration/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/developingPlugins/conventionOverConfiguration/groovy",files="build.gradle[]"]
====

The user specifies only the 'what' - the server the plugin should connect to.
The actual implementation - the 'how' - is entirely abstracted from the end user.

[[capabilities-vs-conventions]]
== Separate capabilities from conventions

Separating capabilities from conventions allows users to choose which tasks and conventions to apply.

For example, the link:{javadocPath}/org/gradle/api/plugins/JavaBasePlugin.html[Java Base plugin] provides un-opinionated functionality and general-purpose concepts like `SourceSets`. The <<java_plugin.adoc#java_plugin,Java plugin>> applies the Java Base plugin and adds tasks and conventions familiar to Java developers like `classes`, `jar` or `javadoc`.

You should consider using the same technique when designing your own plugins; separate capabilities from conventions.
As such, consider the idea of developing two plugins, one for capabilities and another that applies conventions to those capabilities.
You can develop both plugins within the same project and ship their compiled classes and identifiers with the same binary artifact.

The following code example shows how to apply a plugin from another one, this is called _plugin composition_:

.MyBasePlugin.java
[source,java]
----
include::{snippetsPath}/developingPlugins/capabilitiesVsConventions/groovy/buildSrc/src/main/java/MyBasePlugin.java[]
----

.MyPlugin.java
[source,java]
----
include::{snippetsPath}/developingPlugins/capabilitiesVsConventions/groovy/buildSrc/src/main/java/MyPlugin.java[]
----

For inspiration, here are two open-source plugins that apply the concept:

- link:https://bmuschko.github.io/gradle-docker-plugin/#provided_plugins[Docker plugin]
- link:https://github.com/bmuschko/gradle-cargo-plugin#provided-plugins[Cargo plugin]

== Use a statically-typed language

It is recommended to use a statically-typed language like Java or Kotlin for implementing plugins to reduce the likelihood of binary incompatibilities.
If using Groovy, consider using `@groovy.transform.CompileStatic`.

The recommendation to use a statically-typed language is independent from the language choice for writing tests for your plugin code.

[[restricting_the_plugin_implementation_to_gradle_s_public_api]]
== Use Gradle’s public API

To build a Gradle plugin, use a compile-time dependency on the Gradle API:

====
include::sample[dir="snippets/base/customExternalTask/kotlin/task",files="build.gradle.kts[tags=gradle-api-dependencies]"]
include::sample[dir="snippets/base/customExternalTask/groovy/task",files="build.gradle[tags=gradle-api-dependencies]"]
====

This dependency includes the full Gradle runtime, so use only the public API for backward and forward compatibility.

If you can find the class referenced in the DSL guides or the Javadocs, then you can safely assume that it is part of the public API.

== Don't use external libraries

Consider if you really need a specific library for your plugin or if you can implement the functionality yourself.
Using external libraries might introduce conflicts with other versions of the same library being resolved from other plugins.
It will likely also introduce a huge graph of transitive dependencies.

While a Gradle dependency report will not render dependencies declared for the classpath configuration of the build script, effectively the classpath of the declared plugins and their transitive dependencies, you can call the help task `buildEnvironment` to render the full dependency graph.

To demonstrate the functionality let’s assume the following build script:

====
include::sample[dir="snippets/developingPlugins/externalLibraries/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/developingPlugins/externalLibraries/groovy",files="build.gradle[]"]
====

The output of the task clearly indicates the classpath of the `classpath` configuration:

----
$ gradle buildEnvironment
include::{snippetsPath}/developingPlugins/externalLibraries/tests/buildEnvironment.out[]
----

A plugin shares its classloader with the rest of the build, rather than having its own isolated classloader.
This means that the plugin's dependencies and classes are not separate from the rest of the build process.
Third party libraries are likely to create dependency conflicts which will lead to unexpected runtime behavior.
Consider whether you truly need that library or if a simple custom method could suffice.

For logic that is executed as part of task execution, use the <<worker_api.adoc#tasks_parallel_worker, Worker API>> that allows you to isolate libraries.

[[writing-and-using-custom-task-types]]
== Use custom task types

Gradle tasks can be defined in different ways, an <<actionable_tasks.adoc#actionable_tasks,actionable task>> uses a custom task type and exposes its configurability through properties.
Custom tasks offer re-usability, maintainability, configurability, and testability, making them preferable over ad-hoc tasks, especially when providing tasks as part of plugins.

Let's take an example plugin that resolves the latest version of a dependency in a binary repository using HTTP calls.
By providing a custom task type, the plugin handles the communication and response processing in a machine-readable format like XML or JSON.

The end user can easily create multiple tasks of that type with different configurations, while the complex logic remains hidden in the custom task implementation:

.LatestArtifactVersion.java
[source,java]
----
include::{snippetsPath}/developingPlugins/customTask/groovy/buildSrc/src/main/java/org/myorg/LatestArtifactVersion.java[tags=snippet]
----

Users can then create tasks using this custom task type:

====
include::sample[dir="snippets/developingPlugins/customTask/kotlin",files="build.gradle.kts[tags=direct-task-register]"]
include::sample[dir="snippets/developingPlugins/customTask/groovy",files="build.gradle[tags=direct-task-register]"]
====

These principles ensure that your Gradle tasks are well-structured, reusable, and easily configurable, enhancing the overall build process for your projects.

== Benefit from incremental tasks

Gradle uses declared inputs and outputs to determine if a task is `UP-TO-DATE` and needs to perform any work.
If none of the inputs or outputs have changed, Gradle skips that task.
This mechanism, known as <<incremental_build.adoc#incremental_build,incremental build support>>, can significantly improve build performance.

When introducing custom task types in Gradle plugins, it's essential to annotate all task properties with `@Input` or `@Output` annotations.
This ensures that each task has the necessary information so that users can benefit from incremental builds.

For example, consider a task that generates a given number of files in an output directory, with the text written to those files provided by a String property:

.Generate.java
[source,java]
----
include::{snippetsPath}/developingPlugins/incrementalTask/groovy/buildSrc/src/main/java/Generate.java[tags=snippet]
----

As a plugin author, applying the <<java_gradle_plugin#java_gradle_plugin,Plugin Development Plugin>> to your project provides the `validatePlugins` task, which automatically checks for existing input/output annotations for every public property defined in a custom task type implementation.
This ensures that your custom tasks are correctly configured for incremental build support.

[[modeling_dsl_like_apis]]
== Model DSL-like APIs

DSLs exposed by plugins should be readable and easy to understand.

For example, let's consider the following extension provided by a plugin.
In its current form, it offers a "flat" list of properties for configuring the creation of a website:

====
include::sample[dir="snippets/developingPlugins/pluginExtension/kotlin",files="build-flat.gradle.kts[]"]
include::sample[dir="snippets/developingPlugins/pluginExtension/groovy",files="build-flat.gradle[]"]
====

As the number of exposed properties grows, you might want to introduce a nested, more expressive structure.

The following code snippet adds a new configuration block named `customData` as part of the extension.
This provides a stronger indication of what those properties mean:

====
include::sample[dir="snippets/developingPlugins/pluginExtension/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/developingPlugins/pluginExtension/groovy",files="build.gradle[]"]
====

Implementing the backing objects for such an extension is simple.
First, introduce a new data object for managing the properties `websiteUrl` and `vcsUrl`:

.CustomData.java
[source,java]
----
include::{snippetsPath}/developingPlugins/pluginExtension/groovy/buildSrc/src/main/java/org/myorg/CustomData.java[tags=snippet]
----

In the extension, create an instance of the `CustomData` class and a method that can delegate the captured values to the data instance.

To configure underlying data objects, define a parameter of type link:{javadocPath}/org/gradle/api/Action.html[Action].

The following example demonstrates the use of `Action` in an extension definition:

.SiteExtension.java
[source,java]
----
include::{snippetsPath}/developingPlugins/pluginExtension/groovy/buildSrc/src/main/java/org/myorg/SiteExtension.java[tags=snippet]
----

