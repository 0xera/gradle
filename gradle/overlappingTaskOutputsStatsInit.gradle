/*
 * Copyright 2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.gradle.api.internal.tasks.*

def taskInfos = []

class TaskOutputInfo {
    String path
    List<File> outputs
}

gradle.addListener(new TaskExecutionAdapter() {
    @Override
    void afterExecute(Task task, TaskState state) {
        def outputs = task.outputs.fileProperties.findAll { it instanceof CacheableTaskOutputFilePropertySpec }.collect { fileProperty ->
            fileProperty.outputFile
        }

        def info = new TaskOutputInfo(
            path: task.path,
            outputs: outputs
        )
        taskInfos.add info
    }
})
gradle.addListener(new BuildAdapter() {
    @Override
    void buildFinished(BuildResult result) {
        println ""
        println "Overlapping task outputs while executing '${gradle.startParameter.taskNames.join(" ")}':"
        println ""
        taskInfos.sort { a, b ->
            a.path <=> b.path
        }
        def byPath = [:].withDefault { [] }
        def root = rootProject.projectDir
        taskInfos.each { taskInfo ->
            taskInfo.outputs.each { output ->
                byPath[output].add(taskInfo)
            }
        }
        taskInfos.each { taskInfo ->
            taskInfo.outputs.each { output ->
                def path = output
                while (true) {
                    path = path.parentFile
                    if (path == null || path == root) {
                        break;
                    }
                    if (byPath.containsKey(path)) {
                        byPath[path].add(taskInfo)
                    }
                }
            }
        }
        boolean foundAny = false
        byPath.each { path, tasks ->
            if (tasks.size() > 1) {
                foundAny = true
                println "  ${relPath(root, path)} has overlap between ${tasks*.path.join(", ")}"
            }
        }
        if (!foundAny) {
            println "  No tasks with overlapping outputs found"
        }
    }
})

def relPath(File root, File full) {
    root.toURI().relativize(full.toURI()).toString()
}
