/*
 * Copyright 2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import org.gradle.api.internal.tasks.TaskExecutionOutcome
import org.gradle.api.internal.tasks.cache.DefaultTaskCacheKeyBuilder.ByteArrayToStringer
import org.gradle.api.internal.tasks.cache.TaskExecutionStatisticsEventAdapter
import org.gradle.api.internal.tasks.cache.statistics.TaskExecutionStatistics
import org.gradle.internal.classloader.ClassLoaderHierarchyHasher
import org.gradle.internal.classloader.VisitableURLClassLoader

if (plugins.hasPlugin("com.gradle.build-scan")) {
    String commitId
    if (System.getenv("CI")) {
        buildScan.tag "CI"
        buildScan.link "TeamCity Build", System.getenv("BUILD_URL")
        buildScan.value "Build ID", System.getenv("BUILD_ID")
        commitId = System.getenv("BUILD_VCS_NUMBER")
    } else {
        buildScan.tag "LOCAL"

        try {
            commitId = 'git rev-parse --verify HEAD'.execute().text.trim()
        } catch (ignore) {
            // ignore
        }

        try {
            def status = 'git status --porcelain'.execute().text
            if (status) {
                buildScan.tag "dirty"
                buildScan.value "Git Status", status
            }
        } catch (ignore) {
            // ignore
        }
    }

    if (commitId) {
        buildScan.value "Git Commit ID", commitId
        buildScan.link "Source", "https://github.com/gradle/gradle/tree/" + commitId
    }

    // Capture reports from Reporting tasks
    if (System.getenv("CI")) {
        def capturedReportingTypes = ['html'] // can add xml, text, junitXml if wanted
        def basePath = "${System.getenv("BUILD_SERVER_URL")}/repository/download/${System.getenv("BUILD_TYPE_ID")}/${System.getenv("BUILD_ID")}:id"

        gradle.taskGraph.afterTask { Task task, TaskState state ->
            if (task instanceof Reporting && state.failure) {
                (task.reports as ReportContainer<Report>)
                    .findAll { it.name in capturedReportingTypes && it.enabled && it.destination.exists() }
                    .each {
                        def linkName = "${task.class.simpleName.split('_')[0]} Report (${task.path})" // Strip off '_Decorated' addition to class names
                        def reportPath = task.project.rootProject.relativePath(it.destination)
                        def reportLink = "$basePath/$reportPath"
                        task.project.buildScan.link linkName, reportLink
                    }
            }
        }
    }

    if (gradle.startParameter.taskOutputCacheEnabled) {
        buildScan.tag 'CACHED'

        gradle.addListener(new TaskExecutionGraphListener() {
            @Override
            void graphPopulated(TaskExecutionGraph graph) {
                def remainingTasks = graph.allTasks*.path as Set
                gradle.addListener(new TaskExecutionAdapter() {

                    private static addCacheLine(buildScan, name, part, total) {
                        def percentage = total ? (int) Math.round(100d * part / total) : null
                        if (part > 0) {
                            buildScan.value(name, "${part}${percentage ? " (${percentage} %)" : ''}")
                        }
                    }

                    @Override
                    void afterExecute(Task task, TaskState state) {
                        remainingTasks.remove(task.path)
                        if (remainingTasks.empty) {
                            try {
                                def eventAdapter = gradle.services.get(TaskExecutionStatisticsEventAdapter)
                                def statistics = new TaskExecutionStatistics(eventAdapter.taskCounts, eventAdapter.cacheMissCount)
                                def buildScan = task.project.buildScan
                                def skipped = statistics.getTasksCount(TaskExecutionOutcome.SKIPPED)
                                def upToDate = statistics.getTasksCount(TaskExecutionOutcome.UP_TO_DATE)
                                def fromCache = statistics.getTasksCount(TaskExecutionOutcome.FROM_CACHE)
                                def executed = statistics.getTasksCount(TaskExecutionOutcome.EXECUTED)
                                def cacheable = statistics.cacheMissCount
                                def allTasks = statistics.allTasksCount
                                addCacheLine(buildScan, 'TC0 Tasks in build', allTasks, null)
                                addCacheLine(buildScan, 'TC1 Skipped', skipped, allTasks)
                                addCacheLine(buildScan, 'TC2 Up to date', upToDate, allTasks)
                                addCacheLine(buildScan, 'TC3 From cache', fromCache, allTasks)
                                addCacheLine(buildScan, 'TC4 Executed', executed, allTasks)
                                addCacheLine(buildScan, 'TC5 - Cache miss', cacheable, allTasks)
                                addCacheLine(buildScan, 'TC6 - Not cacheable', (executed - cacheable), allTasks)
                            } catch (Exception e) {
                                e.printStackTrace()
                            }
                        }
                    }
                })
            }
        })

        gradle.addListener(new TaskExecutionAdapter() {

            @Override
            void afterExecute(Task task, TaskState state) {
                if (task.getPath() == ':baseServices:classpathManifest') {
                    task.project.buildScan.value(task.getPath(), state.getOutcome().name())
                    def hasher = gradle.services.get(ClassLoaderHierarchyHasher)
                    new Visitor(task.project.buildScan, hasher).visit(task.getClass().getClassLoader())
                }
            }
        })
    }
}

class Visitor extends org.gradle.internal.classloader.ClassLoaderVisitor {
    final buildScan
    final ClassLoaderHierarchyHasher hasher
    int counter

    Visitor(buildScan, ClassLoaderHierarchyHasher hasher) {
        this.buildScan = buildScan
        this.hasher = hasher
    }

    private String classloaderHash(ClassLoader loader) {
        def hash = hasher.getStrictHash(loader)
        if (hash != null) {
            new ByteArrayToStringer(hash.asBytes()).toString()
        } else {
            null
        }
    }

    @Override
    public void visit(ClassLoader classLoader) {
        def hash = classloaderHash(classLoader)
        if (hash) {
            buildScan.value("ClasspathManifest-${counter++}-${classLoader.getClass().getSimpleName()}-hash", hash)
            if ((counter <= 2) && (classLoader instanceof VisitableURLClassLoader)) {
                buildScan.value("ClasspathManifest-${counter - 1}-classpath", classLoader.getURLs().join(':'))
            }
        }
        super.visit(classLoader)
    }
}
