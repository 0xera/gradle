apply plugin: 'java'

sourceSets {
    integTest {
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}

configurations {
    integTestCompile.extendsFrom testCompile
    integTestRuntime.extendsFrom testRuntime
}

dependencies {
    integTestCompile project(":internalIntegTesting")
}

ext.integTestTasks = tasks.withType(Test).matching { it.name.toLowerCase().endsWith('integtest') }

integTestTasks.all { Test task ->
    dependsOn ':intTestImage', { project(":docs").samples }
    testClassesDir = sourceSets.integTest.output.classesDir
    classpath = sourceSets.integTest.runtimeClasspath
    testSrcDirs = []
    jvmArgs '-Xmx512m', '-XX:MaxPermSize=256m', '-XX:+HeapDumpOnOutOfMemoryError'
    maxParallelForks = guessMaxForks(project)

    testResultsDir = file("${project.testResultsDir}/$name")

    systemProperties['org.gradle.integtest.versions'] = project.hasProperty("testAllVersions") ? 'all' : 'latest'
    if (project.hasProperty('crossVersionTestsOnly')) {
        include '**/*CrossVersion*'
    }

    dependsOn project.task("configure${task.name.capitalize()}") << {
        configure(task) {
            testReportDir = file("${project.reporting.baseDir}/$name")
            systemProperties['integTest.gradleHomeDir'] = rootProject.intTestImage.destinationDir.absolutePath
            systemProperties['integTest.gradleUserHomeDir'] = rootProject.file('intTestHomeDir').absolutePath
            systemProperties['integTest.libsRepo'] = rootProject.file('build/repo')
            
            // If the projects int test need the distributions, they should add:
            // inputs.files rootProject.buildDists
            systemProperties['integTest.distsDir'] = rootProject.distsDir.absolutePath
        }
    }
}

task integTest(type: Test) {
    def defaultExecuter = project.hasProperty("defaultIntegTestExecuter") ? project.defaultIntegTestExecuter : "embedded"
    systemProperties['org.gradle.integtest.executer'] = defaultExecuter
}
check.dependsOn(integTest)

['embedded', 'forking', 'daemon', 'embeddedDaemon'].each { mode ->
    def taskName = "${mode}IntegTest"
    tasks.addRule(taskName) { name ->
        if (name == taskName) { 
            tasks.add(taskName, Test).configure {
                systemProperties['org.gradle.integtest.executer'] = mode
            }
        }
    }
}

daemonIntegTest {
    systemProperties['org.gradle.integtest.daemon.registry'] = file("$rootProject.buildDir/daemon").absolutePath
}

if (isCiServer && isWindows) {
    if (!rootProject.tasks.findByName("waitForDaemonsToDie")) {
        rootProject.task("waitForDaemonsToDie") << {
            def mins = 5
            println "I'm waiting for $mins mins so that existing daemons can die with honour. It's a workaround until we fix it properly."
            sleep mins * 60 * 1000
        }
    }

    integTestTasks.all { dependsOn rootProject.waitForDaemonsToDie }
}

plugins.withType(org.gradle.plugins.ide.idea.IdeaPlugin) { // lazy as plugin not applied yet
    idea {
        module {
            testSourceDirs += sourceSets.integTest.groovy.srcDirs
            testSourceDirs += sourceSets.integTest.resources.srcDirs
            scopes.TEST.plus.add(configurations.integTestCompile)
            scopes.TEST.plus.add(configurations.integTestRuntime)
        }
    }
}

plugins.withType(org.gradle.plugins.ide.eclipse.EclipsePlugin) { // lazy as plugin not applied yet
    eclipse {
        classpath {
            plusConfigurations.add(configurations.integTestCompile)
            plusConfigurations.add(configurations.integTestRuntime)
        }
    }
}
