# What is this?

The build migration verification feature provides a way to automatically verify whether a build behaves
the same after modifying it in some way. More precisely, it checks whether the build produces
the same _outputs_ (modulo some allowed variance) as before.

The feature should provide the build
master with information about changes detected in the outputs, and should help him make decisions
on whether to accept or reject a migration. For example, this could be done by classifying detected
changes as expected vs. unexpected, or low risk vs. high risk.

Verification might include running the build before and after migration, or it might just compare
two sets of existing outputs. Apart from verifying a set of changes to a build, the feature might
also support the promotion of those changes. An example would be to set a new Gradle version in
gradle-wrapper.properties.

# Use cases

## Upgrading to a new Gradle version

In order to make Gradle updates less risky and more predictable, the feature should support checking
whether a build produces the same outputs after changing the Gradle version from X to Y. Typically
(but not necessarily), Y will be greater than X.

## Refactoring a Gradle build

In order to make refactoring a Gradle build less risky and more predictable, the feature should support
checking whether a build produces the same outputs after making some configuration changes to it.

## Migrating from Maven to Gradle

In order to make a switch from Maven to Gradle less risky and more predictable, the feature should support
checking whether a build that has been migrated to Gradle behaves the same as the original Maven build.
Which migration methods are supported needs further discussion and won't necessarily influence the
verification side of things.

## Migrating from Ant to Gradle

Similar to the previous use case, except that the source system is Ant.

# User visible changes

The feature will be implemented as a new plugin and a set of new tasks.

# Integration test coverage

The feature can be tested by verifying migrations whose outcome is known.

# Implementation approach

## Upgrading to a new Gradle version

The user adds the 'migration' plugin to the build's root project.

The user issues a command like:

    gradlew migrate -Dfrom=1.0 -Dto=1.1-rc-1

If `from` is unspecified, the current Gradle version is used.

The `migrate` task

* Executes the build with Gradle version `from` (and reconfigured build directory(s))

* Executes the build with Gradle version `to` (and reconfigured build directory(s))

* Compares the Jars, Wars, Ears, Zips, and Tars generated by the two builds

* Compares the XML JUnit and TestNG reports generated by the builds

* Logs some progress information to the console

* Logs a high-level verification result to the console

* Generates a detailed HTML report that can be viewed after verification has completed

* Aborts or skips part of the verification when the artifacts generated by the two builds
cannot be found or cannot be mapped to each other

'Jar', 'War', 'Ear', 'Zip', 'Tar', 'JUnit XML report', and 'TestNG XML report' are artifact
types known to the migration verification plugin. The plugin might ship with one task type
per artifact type, and might add one task per artifact to be compared.

# Open issues - General

* Does verification include execution of the "old" and "new" builds, or can it work off preexisting outputs?

* Who determines what the outputs of a build (or the subset of outputs that should be compared) are, and where
they are located?

* Assuming the feature is implemented as a plugin, where does the plugin and its tasks get executed?
In the old build? The new build? An independent "migration" build?

* How much knowledge does verification need about the "old" and "new" builds? Is it good enough to have two
sets of outputs (together with a mapping between them), or is additional information required?

* How much information does the feature need about how and by whom an artifact that is to be compared was produced?
Does it need to be able to compare different representations of the same information, like a Gradle JUnit report and
an Ant JUnit report (assuming the report formats are different), or a Gradle JUnit report produced by Gradle version X
and one produced by Gradle version Y?

# Open Issues - Upgrading to new Gradle version

* How are the builds executed? Using the tooling API? Using the Gradle wrapper?

* Are the two builds executed in separate processes, or do they (potentially) share a daemon?

* Does the plugin have to make sure that the two builds use separate Gradle metadata (.gradle directory)?


