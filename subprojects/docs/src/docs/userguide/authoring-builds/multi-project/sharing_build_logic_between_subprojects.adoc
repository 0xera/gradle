// Copyright 2020 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
[[sharing_build_logic_between_subprojects]]
= Sharing Build Logic between Subprojects

[[sec:convention_plugins]]
== Convention Plugins

Usually, subprojects in a multi-project build share some common traits.
For example, several subprojects may contain _code_ in a particular programming language while another subproject may be
dedicated for _documentation_.
Code quality rules apply to all of the _code_ subprojects but not the _documentation_ subproject.
At the same time, the subprojects that share one common trait may serve different purposes - they may produce different _artifact types_ that further differentiate them, for example:

- _public libraries_ - libraries that are published to some repository
- _internal libraries_ - libraries on which other subprojects depend internally within the project
- _command line applications_ - applications with specific packaging requirements
- _web services_ - applications with specific packaging requirements that are different from above
- etc

Some other _code_ subprojects may be dedicated for _testing purposes_ and so on.

The traits above identify a subproject's _type_.
Or in other words, a subproject's _type_ tells us what traits the project has.

Gradle's recommended way of organizing build logic is to use its plugin system.
A plugin should define the _type_ of a subproject.
In fact, <<plugin_reference#,Gradle core plugins>> are modeled in the same way - for example <<java_plugin#,java plugin>> configures a generic `java` project,
while <<java_library_plugin#,java-library plugin>> internally applies the <<java_plugin#,java plugin>> and configures aspects specific to a generic Java library.
Similarly, the <<application_plugin#,application plugin>> applies and configures the <<java_plugin#,java plugin>> and the <<distribution_plugin#,distribution plugin>>.

You can compose custom build logic by applying and configuring both core and external plugins and create custom plugins
that define new project _types_ and configure conventions specific to your project or organization.
For each of the example traits from the beginning of this section, we can write a plugin that encapsulates
the logic common to the subproject of a given _type_.

We recommend putting source code and tests for the convention plugins in the special `buildSrc` directory in the root directory of the project.
For more information about `buildSrc`, consult <<organizing_gradle_projects.adoc#sec:build_sources,Using buildSrc to organize build logic>>.

Have a look at the link:../samples/sample_convention_plugins.html[sample that demonstrates a multi-project build that models the build logic using convention plugins].

Another, more complex and real-world example of a multi-project build that composes build logic using convention plugins
is the build of the link:https://github.com/gradle/gradle[Gradle Build Tool] itself.

[[sec:convention_plugins_vs_cross_configuration]]
=== Convention plugins versus cross project configuration

While cross-cutting aspects of subprojects can be configured using <<#sec:cross_project_configuration,cross project configuration>> as well,
doing so will make it harder to understand the logic of a particular subproject.
With cross configuration, build logic can be injected into a subproject and this is not obvious when looking at the subproject's
build script.
In the long run, cross configuration usually grows complex with more and more conditional logic and a higher maintenance burden.
Cross configuration can also introduce <<multi_project_configuration_and_execution#sec:decoupled_projects,configuration-time coupling between projects>>, which can prevent optimizations like
<<multi_project_configuration_and_execution#sec:configuration_on_demand,configuration-on-demand>> from working properly.

There are two most common uses of cross-configuration that can be better modelled using convention plugins:

- Applying plugins or other configuration to subprojects of certain type.
Often the cross-configuration section will do `if subproject is of type X, then configure Y`.
This is equivalent to applying `X-conventions` plugin directly to a subproject.
- Extracting information from subprojects of a certain type.
This use case can be modelled using <<cross_project_publications.adoc#sec:simple-sharing-artifacts-between-projects,outgoing configuration variants>>.

[[sec:cross_project_configuration]]
== Cross-Project Configuration

An alternative to <<#sec:convention_plugins,sharing build logic between subprojects via convention plugins>> is cross project configuration.
This is a powerful feature, but one that should be used with caution.
Before we dive into the details, do check if your <<sec:convention_plugins_vs_cross_configuration,use case can be solved using convention plugins instead>>.

Let's start with a very simple multi-project build.
Gradle is a general purpose build tool at its core, so the projects don't have to be Java projects.
Our first examples are about marine life.


[[sec:defining_common_behavior]]
=== Defining common behavior

Let's look at some examples with the following project tree. This is a multi-project build with a root project named `water` and a subproject named `bluewhale`.

.Multi-project tree - water &amp; bluewhale projects
====
[.multi-language-sample]
=====
.Project layout
[source, groovy]
----
.
├── bluewhale/
├── build.gradle
└── settings.gradle
----
=====
[.multi-language-sample]
=====
.Project layout
[source, kotlin]
----
.
├── bluewhale/
├── build.gradle.kts
└── settings.gradle.kts
----
=====
====


====
include::sample[dir="snippets/multiproject/firstExample/groovy",files="settings.gradle[]"]
include::sample[dir="snippets/multiproject/firstExample/kotlin",files="settings.gradle.kts[]"]
====

And where is the build script for the `bluewhale` project? In Gradle build scripts are optional. Obviously for a single project build, a project without a build script doesn't make much sense. For multiproject builds the situation is different. Let's look at the build script for the `water` project and execute it:

.Build script of water (parent) project
====
include::sample[dir="snippets/multiproject/firstExample/groovy",files="build.gradle[]"]
include::sample[dir="snippets/multiproject/firstExample/kotlin",files="build.gradle.kts[]"]

.Output of **`gradle -q hello`**
----
> gradle -q hello
include::{snippetsPath}/multiproject/firstExample/tests/multiprojectFirstExample.out[]
----
====

Gradle allows you to access any project of the multi-project build from any build script. The Project API provides a method called `project()`, which takes a path as an argument and returns the Project object for this path. The capability to configure a project build from any build script we call _cross project configuration_. Gradle implements this via _configuration injection_.

We are not that happy with the build script of the `water` project. It is inconvenient to add the task explicitly for every project. We can do better. Let's first add another project called `krill` to our multi-project build.

.Multi-project tree - water, bluewhale  &amp; krill projects
====
[.multi-language-sample]
=====
.Project layout
[source, groovy]
----
.
├── bluewhale/
├── build.gradle
├── krill/
└── settings.gradle
----
=====
[.multi-language-sample]
=====
.Project layout
[source, kotlin]
----
.
├── bluewhale/
├── build.gradle.kts
├── krill/
└── settings.gradle.kts
----
=====
====


====
include::sample[dir="snippets/multiproject/addKrill/groovy",files="settings.gradle[]"]
include::sample[dir="snippets/multiproject/addKrill/kotlin",files="settings.gradle.kts[]"]
====

Now we rewrite the `water` build script and boil it down to a single line.

.Water project build script
====
include::sample[dir="snippets/multiproject/addKrill/groovy",files="build.gradle[]"]
include::sample[dir="snippets/multiproject/addKrill/kotlin",files="build.gradle.kts[]"]

.Output of **`gradle -q hello`**
----
> gradle -q hello
include::{snippetsPath}/multiproject/addKrill/tests/multiprojectAddKrill.out[]
----
====

The Project API provides a property `allprojects` which returns a list with the current project and all its subprojects underneath it.
If you call `allprojects` with a closure, the statements of the closure are delegated to the projects associated with `allprojects`.
You could also do an iteration via `allprojects.each` (in Groovy) or `allprojects.forEach` (in Kotlin), but that would be more verbose.

[[sec:subproject_configuration]]
=== Subproject configuration

The Project API also provides a property for accessing the subprojects only.


.Defining common behavior of all projects and subprojects
====
include::sample[dir="snippets/multiproject/useSubprojects/groovy",files="build.gradle[]"]
include::sample[dir="snippets/multiproject/useSubprojects/kotlin",files="build.gradle.kts[]"]

.Output of **`gradle -q hello`**
----
> gradle -q hello
include::{snippetsPath}/multiproject/useSubprojects/tests/multiprojectUseSubprojects.out[]
----
====

You may notice that there are two code snippets referencing the “`hello`” task. The first one, which uses the “`task`” keyword (in Groovy) or the `task()` function (in Kotlin), constructs the task and provides it's base configuration. The second piece doesn't use the “`task`” keyword or function, as it is further configuring the existing “`hello`” task. You may only construct a task once in a project, but you may add any number of code blocks providing additional configuration.

[[sub:adding_specific_behavior]]
==== Adding specific behavior

You can add specific behavior on top of the common behavior. Usually we put the project specific behavior in the build script of the project where we want to apply this specific behavior. But as we have already seen, we don't have to do it this way. We could add project specific behavior for the `bluewhale` project like this:

.Defining specific behaviour for particular project
====
include::sample[dir="snippets/multiproject/subprojectsAddFromTop/groovy",files="build.gradle[]"]
include::sample[dir="snippets/multiproject/subprojectsAddFromTop/kotlin",files="build.gradle.kts[]"]

.Output of **`gradle -q hello`**
----
> gradle -q hello
include::{snippetsPath}/multiproject/subprojectsAddFromTop/tests/multiprojectSubprojectsAddFromTop.out[]
----
====

As we have said, we usually prefer to put project specific behavior into the build script of this project. Let's refactor and also add some project specific behavior to the `krill` project.

.Defining specific behaviour for project krill
====
[.multi-language-sample]
=====
.Project layout
[source, groovy]
----
.
├── bluewhale
│   └── build.gradle
├── build.gradle
├── krill
│   └── build.gradle
└── settings.gradle
----
=====
[.multi-language-sample]
=====
.Project layout
[source, kotlin]
----
.
├── bluewhale
│   └── build.gradle.kts
├── build.gradle.kts
├── krill
│   └── build.gradle.kts
└── settings.gradle.kts
----
=====
====


====
include::sample[dir="snippets/multiproject/spreadSpecifics/groovy",files="settings.gradle[];bluewhale/build.gradle[];krill/build.gradle[];build.gradle[]"]
include::sample[dir="snippets/multiproject/spreadSpecifics/kotlin",files="settings.gradle.kts[];bluewhale/build.gradle.kts[];krill/build.gradle.kts[];build.gradle.kts[]"]

.Output of `gradle -q hello`
----
> gradle -q hello
include::{snippetsPath}/multiproject/spreadSpecifics/tests/multiprojectSpreadSpecifics.out[]
----
====

[[sub:project_filtering]]
==== Project filtering

To show more of the power of configuration injection, let's add another project called `tropicalfish` and add more behavior to the build via the build script of the `water` project.


[[ssub:filtering_by_name]]
==== Filtering by name

.Adding custom behaviour to some projects (filtered by project name)
====
[.multi-language-sample]
=====
.Project layout
[source, groovy]
----
.
├── bluewhale/
│   └── build.gradle
├── build.gradle
├── krill/
│   └── build.gradle
├── settings.gradle
└── tropicalfish/
----
=====
[.multi-language-sample]
=====
.Project layout
[source, kotlin]
----
.
├── bluewhale/
│   └── build.gradle.kts
├── build.gradle.kts
├── krill/
│   └── build.gradle.kts
├── settings.gradle.kts
└── tropicalfish/
----
=====
====


====
include::sample[dir="snippets/multiproject/addTropical/groovy",files="settings.gradle[];build.gradle[]"]
include::sample[dir="snippets/multiproject/addTropical/kotlin",files="settings.gradle.kts[];build.gradle.kts[]"]

.Output of `gradle -q hello`
----
> gradle -q hello
include::{snippetsPath}/multiproject/addTropical/tests/multiprojectAddTropical.out[]
----
====

The `configure()` method takes a list as an argument and applies the configuration to the projects in this list.

[[ssub:filtering_by_properties]]
==== Filtering by properties

Using the project name for filtering is one option. Using <<writing_build_scripts.adoc#sec:extra_properties,extra project properties>> is another.

.Adding custom behaviour to some projects (filtered by project properties)
====
[.multi-language-sample]
=====
.Project layout
[source, groovy]
----
.
├── bluewhale
│   └── build.gradle
├── build.gradle
├── krill
│   └── build.gradle
├── settings.gradle
└── tropicalfish
    └── build.gradle
----
=====
[.multi-language-sample]
=====
.Project layout
[source, kotlin]
----
.
├── bluewhale
│   └── build.gradle.kts
├── build.gradle.kts
├── krill
│   └── build.gradle.kts
├── settings.gradle.kts
└── tropicalfish
    └── build.gradle.kts
----
=====
====


====
include::sample[dir="snippets/multiproject/tropicalWithProperties/groovy",files="settings.gradle[];bluewhale/build.gradle[];krill/build.gradle[];build.gradle[];tropicalfish/build.gradle[]"]
include::sample[dir="snippets/multiproject/tropicalWithProperties/kotlin",files="settings.gradle.kts[];bluewhale/build.gradle.kts[];krill/build.gradle.kts[];build.gradle.kts[];tropicalfish/build.gradle.kts[]"]

.Output of `gradle -q hello`
----
> gradle -q hello
include::{snippetsPath}/multiproject/tropicalWithProperties/tests-common/multiprojectTropicalWithProperties.out[]
----
====

In the build file of the `water` project we use an `afterEvaluate` notification.
This means that the closure we are passing gets evaluated _after_ the build scripts of the subprojects are evaluated.
As the property `arctic` is set in those build scripts, we need to have them evaluated before this property becomes available.
