// Copyright 2017 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[part3_gradle_dep_man]]
= Part 3: Understand Gradle's Dependency Management

Learn the basics of Gradle's dependency management.

****
**In this section you will:**

- View dependencies in the project
- Add dependencies to the project
- Understand transitive dependencies
****

[[part3_begin]]
== Before you begin

1. Complete <<part2_gradle_tasks#part2_begin,part 2>>.

== Step 1. View dependencies
Gradle provides excellent support for dependency management and automation.

Let's take another look at our build script (the `gradle.build` file).
Specifically the following section:
[source]
----
repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // Use JUnit test framework.
    testImplementation("junit:junit:4.13.2")

    // This dependency is used by the application.
    implementation("com.google.guava:guava:31.1-jre")
}
----

The key concepts to Gradle dependency management:

Repositories :: `mavenCentral()` - a source of dependencies
Dependencies :: `junit` and `guava` - dependencies declared via configuration types

For the repositories, the build file contains https://mvnrepository.com/repos/central[Maven Central] which is a collection of jar files, plugins, and libraries provided by the Maven community.

For the dependencies, the build file contains https://mvnrepository.com/artifact/junit/junit[JUnit] which is a unit testing framework to write and run repeatable automated tests on Java.
It also includes https://mvnrepository.com/artifact/com.google.guava/guava[Guava], a suite of core and expanded libraries from Google that include utility classes, Google's collections, I/O classes, and more.

Gradle needs specific information to find a dependency.
Let's look at `com.google.guava:guava:31.1-jre` and `junit:junit:4.13.2`; they are broken down as follows:

[cols="10h,30,30,30"]
|===
| |Description | com.google.guava:guava:31.1-jre | junit:junit:4.13.2

|Group
|identifier of an organization
|`com.google.guava`
|`junit`

|Name
|dependency identifier
|`guava`
|`junit`

|Version
|version # to import
|`31.1-jre`
|`4.13.2`
|===

In the `tutorial` directory, enter the command below to list all the dependencies:
[source]
----
$ ./gradlew :app:dependencies

> Task :app:dependencies

------------------------------------------------------------
Project ':app'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
\--- com.google.guava:guava:31.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.12.0
     +--- com.google.errorprone:error_prone_annotations:2.11.0
     \--- com.google.j2objc:j2objc-annotations:1.3
----

As you can see, there is a lot more than just `junit` and `guava` here.
The reason for this is called _transitive dependencies_.

Transitive dependencies are the dependencies `junit` and `guava` need to work.
A _transitive dependency_ is a dependency of a dependency.

When listing dependencies in the project using `./gradlew :app:dependencies`, we see that to compile the code, the `guava` dependency is used.
At compilation time (`compileClasspath`), `guava` requires `failureaccess`, `listenablefuture`, `findbugs`, `checker-qual`, `error_prone_annotations`, and `j2objc-annotations` as additional dependencies.

[source]
----
testRuntimeClasspath - Runtime classpath of source set 'test'.
+--- com.google.guava:guava:31.1-jre
|    +--- com.google.guava:failureaccess:1.0.1
|    +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
|    +--- com.google.code.findbugs:jsr305:3.0.2
|    +--- org.checkerframework:checker-qual:3.12.0
|    +--- com.google.errorprone:error_prone_annotations:2.11.0
|    \--- com.google.j2objc:j2objc-annotations:1.3
\--- junit:junit:4.13.2
     \--- org.hamcrest:hamcrest-core:1.3
----

At testing time (`testRuntimeClasspath`), `guava` requires `failureaccess`, `listenablefuture`, `findbugs`, `checker-qual`, `error_prone_annotations`, and `j2objc-annotations`. `junit` has only one transitive dependency called `hamcrest-core`.

If you are interested, you can view `hamcrest-core` in the https://mvnrepository.com/artifact/org.hamcrest/hamcrest-core[Maven repository].

So what is `testRuntimeClasspath` and `compileClasspath`? What about `runtimeOnly`, `testCompileClasspath` and `runtimeClasspath`? These are called _configurations_ and are dependent on the type of project your are building.

Gradle provides the following dependencies configuration types:

[width=100%]
|===
|Configuration |Description

|**api**
|required for compile and runtime (exposed to consumers)

|**implementation**
|required for compile and runtime

|**compileOnly**
|required only at app compile time

|**compileOnlyApi**
|required only at app compile time (exposed to consumers)

|**runtimeOnly**
|required only at app runtime

|**testImplementation**
|required to compile tests

|**testCompileOnly**
|required only at test compile time

|**testRuntimeOnly**
|required only at test runtime
|===

The `api` configurations are not applicable in a Java app project.
If you recall in <<part1_gradle_init.adoc#part1_begin,part 1>>, the Gradle init script gave you the option to create an api project instead of the Java project. In that case, the `api` configuration would be available.

Returning to our build script:
[source]
----
dependencies {
    // Use JUnit test framework.
    testImplementation("junit:junit:4.13.2")

    // This dependency is used by the application.
    implementation("com.google.guava:guava:31.1-jre")
}
----

We've specifically told Gradle to add `junit` as a requirement only when building tests (so it is not used to build the `app` source code).

We have also configured `guava` to be used both a compile and runtime.

== Step 2. Add dependencies
Let's add logging to our app.
We will used a popular dependency called https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j[log4j].

Log4j 2 is a powerful logging framework for Java applications, which provides many advanced features such as asynchronous logging, custom appenders, and multiple logging levels.

Add the `log4j` dependency to the `gradle.build.kts` file:
[source]
----
implementation("org.apache.logging.log4j:log4j-core:2.16.0")
implementation("org.apache.logging.log4j:log4j-api:2.16.0")
----

If you change the file using the IntelliJ IDE, don't forget to click the `sync` Gradle button:

image::tutorial/intellij-idea-dep-man.png[]

Run `./gradlew :app:dependencies` in the terminal, to check that `log4j` has been added to the dependency tree:
[source]
----
testRuntimeClasspath - Runtime classpath of source set 'test'.
+--- com.google.guava:guava:31.1-jre
|    +--- com.google.guava:failureaccess:1.0.1
|    +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
|    +--- com.google.code.findbugs:jsr305:3.0.2
|    +--- org.checkerframework:checker-qual:3.12.0
|    +--- com.google.errorprone:error_prone_annotations:2.11.0
|    \--- com.google.j2objc:j2objc-annotations:1.3
+--- org.apache.logging.log4j:log4j-core:2.16.0
|    \--- org.apache.logging.log4j:log4j-api:2.16.0
+--- org.apache.logging.log4j:log4j-api:2.16.0
\--- junit:junit:4.13.2
     \--- org.hamcrest:hamcrest-core:1.3
----

== Step 3. Update the Java Code
To use Log4j in your app, you need to create a logger object and call its methods to log messages.

Update `tutorial/app/src/main/java/com.gradle.tutorial/App.java` with the code below:
[source,java]
----
package com.gradle.tutorial;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    private static final Logger logger = LogManager.getLogger(App.class);

    public static void main(String[] args) {

        logger.info("Application started");
        logger.warn("Something went wrong");

        System.out.println(new App().getGreeting());
    }
}
----

In this example, we create a logger object using the `LogManager.getLogger` method, passing in the class name of the logger (`App.class`).
We then call the loggerâ€™s `info` and `warn` methods to log messages at the _info_ and _warn_ levels, respectively.

== Step 4. Run the Java Code
In your terminal, run `./gradlew :app:run`:
[source]
----
./gradlew :app:run

> Task :app:run
17:17:39.659 [main] INFO  com.gradle.tutorial.App - Application started
17:17:39.660 [main] WARN  com.gradle.tutorial.App - Something went wrong
Hello World!
----

Gradle added the Log4j dependency, built the app by resolving all dependencies, and ran it successfully.

[.text-right]
**Next Step:** <<part4_gradle_plugins#part4_begin,Apply Gradle Plugins and Distribute your App>> >>
