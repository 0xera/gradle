// Copyright 2018 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[migrating_from_ant]]
= Migrating Builds From Apache Ant

https://ant.apache.org/[Apache Ant] is a build tool with a long history in the Java world and it is still widely used. While flexible, it lacks conventions and many of the powerful features that Gradle can provide. So migrating to Gradle is often worth the effort.

The biggest problem with migrating from Ant to Gradle is that there is no such thing as a standard Ant build! That makes it difficult to provide specific instructions. Fortunately, Gradle has some great integration features with Ant that can make the process smoother. And even migrating from https://ant.apache.org/ivy/[Ivy]-based dependency management isn't particularly hard because Gradle has a similar model based on <<dependency_management_terminology#sub:terminology_configuration,dependency configurations>> and it works with Ivy-compatible repositories.

We will start by outlining the kinds of approaches you can take to migrating from Ant and offer some general guidelines.

== General guidelines

When you undertake to migrate a build from Ant to Gradle, you should keep in mind the nature of both what you already have and where you would like to end up. Do you want a Gradle build that mirrors the structure of the existing Ant build? Or do you want to move to something that is more idiomatic to Gradle? This is an important decision that will impact the difficulty of the migration and the benefits you accrue from switching to Gradle.

To understand the implications, it may be useful to look at the two extremes:

 1. Using <<ant.html#sec:import_ant_build,`ant.importBuild()`>> to import the Ant build wholesale into Gradle.
+
This approach is quick and simple and works for many Ant-based builds. Your targets become Gradle tasks that you can run, and the dependencies between targets are retained.
+
The downside is that you lose the advantages of Gradle's conventions, many of its plugins, and many of its important features like incremental build, proper multi-project support, the build cache, and more.
 2. Creating the Gradle build from scratch.
+
This sounds intimidating, but you may be surprised at how much heavy lifting Gradle's plugins can do. You will often find that large swathes of an Ant build are unnecessary in the equivalent Gradle one. The big advantage of this approach is that you gain access to all of Gradle's most important features.
+
The downside is that many builds will have behavior that can't be replicated by existing plugins, so the migration will take time and effort. You also need a good understanding of what the Ant build is doing in order to match the behavior in Gradle accurately.

With those approaches in mind, the first thing you should decide is whether your project is a good fit for any of the standard Gradle project types. We expect that the vast majority of Ant builds are for JVM-based projects that do the same sorts of things:

 * Compile classes
 * Run tests
 * Create JAR packages
 * Produce Javadoc API documentation
 * Manage dependencies

There are other common tasks that depend on whether the build produces a library, an application, a webapp, and so on, for which Gradle has specific plugins.

If you have such a build, we recommend that you take the approach of creating a Gradle build from scratch using the appropriate plugins — such as the Java Plugin as described in the chapter <<building_java_projects#building_java_projects,Building Java & JVM projects>> — and configuring them as necessary. You might even want to consider changing the directory structure of your project to match Gradle's conventions, e.g. `src/main/java` for Java source files, although you can usually retain the structure and inform Gradle about it via <<building_java_projects#sec:custom_java_source_set_paths,source-set configuration>>.

If your build isn't a good fit for the standard plugins, then you're probably better off using `ant.importBuild()` and updating the build piecemeal to take advantage of features like incremental build. link:{javadocPath}org/gradle/api/AntBuilder.html#importBuild-java.lang.Object-org.gradle.api.Transformer-[Variant that allows you to change the name of tasks on import].

Whichever approach you take, there are some common scenarios you will likely have to deal with during the migration, and we cover those in the rest of the chapter.

== Managing dependencies

Ant builds typically take one of two approaches to dealing with dependencies:

 * Storing them with the project in a local "lib" directory
 * Using https://ant.apache.org/ivy/[Ivy] to manage them

Gradle can work with either situation with the appropriate configuration.

=== Serving dependencies from a directory

You can use local dependencies with Gradle in one of two ways:

 * Define a <<repository_types#sec:flat_dir_resolver,flat-directory repository>> and use standard dependency declarations
 * Attach the files directly to the appropriate dependency configurations — these are known as <<declaring_dependencies#sec:declaring_file_dependency,file dependencies>>

It's easier to migrate to managed dependencies served from Maven- or Ivy-compatible repositories if you take the first approach, but doing so requires all your files to have a version in their name.

To demonstrate the two techniques, consider a project that has the following library JARs in its `libs` directory:

[listing]
libs
├── our-custom.jar
├── log4j-1.2.8.jar
└── commons-io-2.1.jar

The custom JAR won't work with a flat-directory repository because it has no version number, but the other two JARs are fine. The following sample build script demonstrates how you can incorporate all of these libraries into a build:

[source,groovy]
----
repositories {
    flatDir {
        name = 'libs dir'
        dir file('libs')  // <1>
    }
}

dependencies {
    implementation files('libs/our-custom.jar')  // <2>
    implementation ':log4j:1.2.8', ':commons-io:2.1'  // <3>
}
----
<1> Specifies the path to the directory containing the JAR files
<2> Declares a _file dependency_ for the unversioned JAR
<3> Declares dependencies using standard dependency coordinates (minus the group) — note the leading `:`

The above sample will add `our-custom.jar`, `log4j-1.2.8.jar` and `commons-io-2.1.jar` to the `implementation` configuration, which is used to compile the project's code.

NOTE: You can specify a group in the dependency coordinates because the flat-directory repository simply ignores that information. If you add a normal Maven- or Ivy-compatible repository at a later date, Gradle will then download the dependencies with a specified group from that repository rather than the flat-directory one.

=== Migrating Ivy dependencies

Apache Ivy is a standalone dependency management tool that is widely used with Ant. It works in a similar fashion to Gradle. In fact, they both allow you to

 * Define your own configurations
 * Extend configurations from one another
 * Attach dependencies to configurations
 * Resolve dependencies from Ivy-compatible repositories
 * Publish artifacts to Ivy-compatible repositories

The most notable difference is that Gradle has standard configurations for specific types of projects. For example, the <<java_plugin#configurations,Java Plugin>> defines configurations like `implementation`, `testImplementation` and `runtimeOnly`. You can still <<managing_dependency_configurations#defining_custom_configurations,define your own dependency configurations>>, though.

This similarity means that it's usually quite straightforward to migrate from Ivy to Gradle:

 * Transcribe the dependency declarations from your module descriptors into the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure)[dependencies {}] block of your Gradle build script, ideally using the standard configurations provided by any plugins you apply.
 * Transcribe any configuration declarations from your module descriptors into the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure)[configurations {}] block of the build script for any custom configurations that can't be replaced by Gradle's standard ones.
 * Transcribe the resolvers from your Ivy settings file into the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)[repositories {}] block of the build script.

See the chapters on <<declaring_dependencies#declaring_dependencies,Declaring Dependencies>>, <<managing_dependency_configurations#managing_dependency_configurations,Managing Dependency Configurations>> and <<declaring_repositories#declaring_repositories,Declaring Repositories>> for more information.

Ivy provides several Ant tasks that handle Ivy's process for fetching dependencies. The basic steps of that process consist of:

 1. _Configure_ — applies the configuration defined in the Ivy settings file
 2. _Resolve_ — locates the declared dependencies and downloads them to the cache if necessary
 3. _Retrieve_ — copies the cached dependencies to another directory

Gradle's process is similar, but you don't have to explicitly invoke the first two steps. It performs them automatically. The third step doesn't happen at all — unless you create a task to do it — because Gradle typically uses the files in the dependency cache directly in classpaths and as the source for assembling application packages.

Let's look at how Ivy's steps map to Gradle:

Configuration::
Most of Gradle's dependency-related configuration is baked into the build script, as you've seen with elements like the `dependencies {}` block. Another particularly important configuration element is link:{groovyDslPath}/org.gradle.api.artifacts.ResolutionStrategy.html[resolutionStrategy], which is accessible on dependency configurations. This provides many of the features you might get from Ivy's conflict managers and is a powerful way to control transitive dependencies and caching.
+
Some Ivy configuration options have no equivalent in Gradle. For example, there are no lock strategies because Gradle ensures that its dependency cache is concurrency safe, period. Nor are there "latest strategies" because it's simpler to have a reliable, single strategy for conflict resolution. If the "wrong" version is picked, you can easily override it using forced versions or other resolution strategy options.
+
See the chapters on <<managing_transitive_dependencies#managing_transitive_dependencies,Managing Transitive Dependencies>> and <<customizing_dependency_resolution_behavior#customizing_dependency_resolution_behavior,Customizing Dependency Resolution Behavior>> for more information on this aspect of Gradle.

Resolution::
Gradle will automatically resolve any dependencies you have declared and download them to its cache. It searches for dependencies in the repositories, with the search order defined by <<declaring_repositories#sec:declaring_multiple_repositories,the order in which the repositories declared>>.
+
It's worth noting that Gradle supports the same dynamic version syntax as Ivy, so you can still use versions like `1.0.+`. You can also use the special `latest.integration` and `latest.release` labels if you wish. You can also configure the caching behavior for dynamic and changing versions via link:{groovyDslPath}/org.gradle.api.artifacts.ResolutionStrategy.html[resolutionStrategy].

Retrieval::
As mentioned, Gradle does not automatically copy files from the dependency cache. Its standard tasks typically use the files directly. If you want to copy the dependencies to a local directory, you can use something like this in your build script:
+
[source,groovy]
----
task retrieveRuntimeDependencies(type: Copy) {
    into 'libs'
    from configurations.runtimeClasspath
}
----
+
A configuration is also a file collection, hence why it can be used in the `from()` configuration. You can use a similar technique to attach a configuration to a compilation task or one that produces documentation. See the chapter on <<working_with_files#working_with_files,Working with Files>> for more examples and information on Gradle's file API.

== Publishing artifacts

Projects that use Ivy to manage dependencies often use it for publishing JARs and other artifacts to repositories. If you're migrating such a build, then you'll be glad to know that Gradle has built-in support for publishing artifacts to Ivy-compatible repositories.

Before you attempt to migrate this particular aspect of your build, read the <<publishing_overview#publishing_overview,publishing overview>> chapter to learn about Gradle's publishing model. That chapter's examples are based on Maven repositories, but the same model is used for Ivy repositories as well.

The basic migration process looks like this:

 * Apply the <<publishing_ivy#publishing_ivy,Ivy Publish Plugin>> to your build
 * <<publishing_ivy#publishing_ivy:publications,Configure at least one publication>>, representing what will be published (including additional artifacts if desired)
 * <<publishing_ivy#publishing_ivy:repositories,Configure one or more repositories to publish artifacts to>>

Once that's all done, you'll be able to generate an Ivy module descriptor for each publication and publish them to one or more repositories.

Let's say you have defined a publication named "myLibrary" and a repository named "myRepo". The Ivy tasks would then map to the Gradle tasks like this:

 * `<deliver>` -> `generateDescriptorFileForMyLibraryPublication`
 * `<publish>` -> `publishMyLibraryPublicationToMyRepoRepository`

There is also a `publish` task that publishes all publications to all repositories. You could also define your own aggregate task that depends on just a subset of those publishing tasks.

.On dependency versions
[NOTE]
====
Ivy will, by default, automatically replace dynamic versions of dependencies with the resolved "static" versions when it generates the module descriptor. Gradle does _not_ mimic this behavior: declared dependency versions are left unchanged.

You can replicate the default Ivy behavior by using the https://plugins.gradle.org/plugin/nebula.ivy-resolved-dependencies[Nebula Ivy Resolved Plugin]. Alternatively, you can link:{groovyDslPath}/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html#org.gradle.api.publish.ivy.IvyModuleDescriptorSpec:withXml(org.gradle.api.Action)[customize the descriptor file] so that it contains the versions you want.
====

== Dealing with custom tasks

One of the advantages of Ant is that it's fairly easy to create a custom task and incorporate it into a build. If you have such tasks, then you have two main options for a migration:

 * <<ant#sec:using_custom_ant_tasks,Use the custom Ant task>> from the Gradle build
 * Rewrite the task as a <<custom_tasks#custom_tasks,custom Gradle task type>>

The first option is usually quick and easy, but not always. And if you want to integrate the task into incremental build, you must use the <<more_about_tasks#sec:task_input_output_runtime_api,incremental build runtime API>>. You also often have to work with Ant paths and filesets, which are clunky.

The second option is preferable in the long term, if you have the time. Gradle task types tend to be simpler than Ant tasks because they don't have to work with an XML-based interface. You also gain access to Gradle's rich APIs. Lastly, this approach can make use of the <<more_about_tasks#sec:task_input_output_annotations,type-safe incremental build API>> based on typed properties.

== Working with files

Ant has many tasks for working with files, most of which have Gradle equivalents. As with other areas of Ant to Gradle migration, you can <<ant#sec:using_ant_tasks,use those Ant tasks>> from within your Gradle build. However, we strongly recommend migrating to native Gradle constructs where possible so that the build benefits from:

 * <<more_about_tasks#sec:up_to_date_checks,Incremental build>>
 * Easier integration with other parts of the build, such as dependency configurations
 * More idiomatic build scripts

That said, it can be convenient to use those Ant tasks that have no direct equivalents, such as `<checksum>` and `<chown>`. Even then, in the long run it may be better to convert these to native Gradle task types that make use of standard Java APIs or third-party libraries to achieve the same thing.

Here are the most common file-related elements used by Ant builds, along with the Gradle equivalents:

 * `<copy>` — prefer the Gradle link:{groovyDslPath}/org.gradle.api.tasks.Copy.html[Copy] task type
 * `<zip>` (plus Java variants) — prefer the link:{groovyDslPath}/org.gradle.api.tasks.bundling.Zip.html[Zip] task type (plus link:{groovyDslPath}/org.gradle.api.tasks.bundling.Jar.html[Jar], link:{groovyDslPath}/org.gradle.api.tasks.bundling.War.html[War], and link:{groovyDslPath}/org.gradle.plugins.ear.Ear.html[Ear])
 * `<unzip>` — prefer using the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)[Project.zipTree()] method with a `Copy` task

You can see several examples of Gradle's file API and learn more about it in the <<working_with_files#working_with_files,Working with Files>> chapter.

.On paths and filesets
[NOTE]
====
Ant makes use of the concepts of path-like structures and filesets to enable users to work with collections of files and directories. Gradle has a simpler, more powerful model based on link:{javadocPath}/org/gradle/api/file/FileCollection.html[FileCollection]s and link:{javadocPath}/org/gradle/api/file/FileTree.html[FileTree]s that can be treated as objects from within the build. Both types of file collection support filtering that uses Ant's glob syntax, e.g. `**/books_*`. Learn more about both types in the <<working_with_files#working_with_files,Working with Files>> chapter.

You can still construct Ant paths and filesets from within your build if you need to interact with an Ant task that requires them. There is even link:{javadocPath}/org/gradle/api/file/FileCollection.html#addToAntBuilder-java.lang.Object-java.lang.String-org.gradle.api.file.FileCollection.AntType-[a method on `FileCollection`] for converting a file collection to a fileset or similar Ant type.
====

== Migrating Ant properties

Ant makes use of a properties map to store values that can be reused through the build. The big downsides to this approach are that property values are all strings and the properties themselves behave like global variables.

.Interacting with Ant properties in Gradle
[TIP]
====
Sometimes you will want to make use of an Ant task directly from your Gradle build and that task requires one or more Ant properties to be set. If that's the case, you can easily set those properties via the `ant` object, as described in the <<ant#sec:ant_properties,Using Ant from Gradle>> chapter.
====

Gradle does use something similar in the form of <<build_environment#sec:project_properties,project properties>>, which are a reasonable way to parameterize a build. These can be set from the command line, in a <<build_environment#sec:gradle_configuration_properties,`gradle.properties` file>>, or even via specially named system properties and environment variables.

However, it's important to understand that a Gradle build script works with an object-oriented API and it's often best to use the properties of tasks, source sets and other objects where possible. For example, this build script fragment creates tasks for packaging Javadoc documentation as a JAR and unpacking it, linking tasks via their properties:

[source,groovy]
----
task javadocJar(type: Jar) {
    from javadoc  // <1>
    classifier = 'javadoc'
}

task unpackJavadocs(type: Copy) {
    from zipTree(javadocJar.archivePath)  // <2>
    into tmpDistDir  // <3>
}
----
<1> Packages all `javadoc`'s output files — equivalent to `from javadoc.destinationDir`
<2> Uses the location of the Javadoc JAR held by the `javadocJar` task
<3> Assumes an extra project property called `tmpDistDir` has been defined

As you can see from the example, there is often still a need to define paths and the like through properties, which is why Gradle also provides <<writing_build_scripts#sec:extra_properties,extra properties>>, which can be attached to the project, tasks and some other types of objects.

== Migrating multi-project builds

Multi-project builds are a particular challenge to migrate because there is no standard approach in Ant for either structuring them or handling inter-project dependencies. Most of them likely use the `<ant>` task in some way, but that's about all that one can say.

Fortunately, Gradle's multi-project support can handle fairly diverse project structures and it provides much more robust and helpful support for constructing and maintaining multi-project builds. The `ant.importBuild()` method also handles `<ant>` and `<antcall>` tasks transparently, which allows for a phased migration.

We will suggest one process for migration here and hope that it either works for your case or at least gives you some ideas. It breaks down like this:

 1. Start by learning <<multi_project_builds#multi_project_builds,how Gradle configures multi-project builds>>.
 2. Create a Gradle build script in each project of the build, setting their content to this line:
+
[source,groovy]
----
ant.importBuild 'build.xml'
----
+
Replace `build.xml` with the path to the actual Ant build file that corresponds to the project. If there is no corresponding Ant build file, leave the Gradle build script empty. Your build may not be suitable for this migration approach, but continue with these steps to see whether there is still a way to do a phased migration.
 3. Create a settings file that link:{groovyDslPath}/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String++[]++)[includes all the projects] that now have a Gradle build script.
 4. Develop a mechanism to verify that the Gradle build produces the same artifacts as the Ant build
+
This is a vitally important step to ensure that your deployments and tests don't break. Even small changes, such as the contents of a manifest file in a JAR, can cause problems. If your Gradle build produces the same output as the Ant build, this will give you and others confidence in switching over and make it easier to implement the big changes that will provide the greatest benefits.
 5. Implement inter-project dependencies.
+
Some projects in your multi-project build will depend on artifacts produced by one or more other projects in that build. Such projects need to ensure that those projects they depend on have produced their artifacts and that they know the paths to those artifacts.
+
Ensuring the production of the required artifacts typically means calling into other projects' builds via the `<ant>` task. This unfortunately bypasses the Gradle build, negating any changes you make to the Gradle build scripts. You will need to replace targets that use `<ant>` tasks with Gradle <<more_about_tasks#sec:adding_dependencies_to_tasks,task dependencies>>.
+
For example, imagine you have a web project that depends on a "util" library that's part of the same project. The Ant build file for "web" might have a target like this:
+
.web/build.xml
[source,xml]
----
<target name="buildRequiredProjects">
    <ant antfile="${root.dir}/util" target="build"/>
</target>
----
+
This can be replaced by an inter-project task dependency in the corresponding Gradle build script. In the following example, we assume that the "web" Ant build has a "compile" target that is dependent on the "util" library:
+
.web/build.gradle
[source,groovy]
----
ant.importBuild 'build.xml'

compile.dependsOn ':util:build'
----
+
This is not as robust or powerful as Gradle's <<multi_project_builds#sec:project_jar_dependencies,project dependencies>>, but it solves the immediate problem without big changes to the build.
 6. Identify the projects that have no dependencies on other projects and migrate them to idiomatic Gradle builds scripts.
+
Just follow the advice in the rest of this guide to migrate individual project builds. As mentioned elsewhere, you should ideally use Gradle standard plugins where possible. This may mean that you need to add an extra copy task to each build that copies the generated artifacts to the location expected by the rest of the Ant builds.
 7. Migrate projects as and when they only depend on projects with fully migrated Gradle builds.
+
At this point, you should be able to switch to using proper project dependencies attached to the appropriate dependency configurations.
 8. Clean up projects once no Ant build depends on them.
+
We mentioned in step 6 that you might need to add copy tasks to satisfy the requirements of dependent Ant builds. Once those builds have been migrated, such build logic will no longer be needed and should be removed.

At the end of the process you should have a Gradle build that you are confident works as it should, with much less build logic than before.

== Further reading

This chapter has covered the major topics that are specific to migrating Ant builds to Gradle. All that remain are a few areas that may also be useful during or after a migration:

 * Learn how to configure Gradle's <<build_environment#build_environment,build environment>>, including the JVM settings used to run it
 * Learn how to <<organizing_gradle_projects#organizing_gradle_projects,structure your builds effectively>>
 * <<logging#logging,Configure Gradle's logging>> and use it from your builds

As a final note, this guide has only touched on a few of Gradle's features and we encourage you to learn about the rest from the other chapters of the user manual and from our tutorial-style {guidesUrl}/[Gradle Guides].
