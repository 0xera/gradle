// Copyright 2018 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[migrating_from_maven]]
= Migrating Builds From Apache Maven

https://maven.apache.org[Apache Maven] is a build tool for Java and other JVM-based projects that's in widespread use, and so people that want to use Gradle often have to migrate an existing Maven build.
This guide will help with such a migration by explaining the differences and similarities between the two tools' models and providing steps that you can follow to ease the process.

Converting a build can be scary, but you don't have to do it alone.
You can search docs, forums, and StackOverflow from link:https://gradle.org/help[help.gradle.org] or reach out to the link:https://discuss.gradle.org/c/help-discuss[Gradle community on the forums] if you get stuck.

[[migmvn:making_a_case]]
== Making a case for migration

The primary differences between Gradle and Maven are flexibility, performance, user experience, and dependency management.
A visual overview of these aspects is available in the link:https://gradle.org/maven-vs-gradle[Maven vs Gradle feature comparison].

Since Gradle 3.0, Gradle has invested heavily in making Gradle builds much faster, with features such as link:https://blog.gradle.org/introducing-gradle-build-cache[build caching], link:https://blog.gradle.org/incremental-compiler-avoidance[compile avoidance], and an improved incremental Java compiler.
Gradle is now 2-10x faster than Maven for the vast majority of projects, even without using a build cache.
In-depth performance comparison and business cases for switching from Maven to Gradle can be found link:https://gradle.org/gradle-vs-maven-performance/[here].

[[migmvn:understanding_the_differences]]
== Understanding the functional differences

Gradle and Maven have fundamentally different views on how to build a project.
Gradle is based on a <<what_is_gradle#2_the_core_model_is_based_on_tasks,_graph of task dependencies_>>, where the tasks do the work.
Maven uses a model of fixed, linear phases to which you can attach goals (the things that do the work).
Despite this, migrations can be surprisingly easy because Gradle follows many of the same conventions as Maven and dependency management works in a similar way.

One especially useful feature for understanding your new Gradle build is link:https://scans.gradle.com/[build scans]: these are  web-based snapshots of a given build that allows collaborative debugging and fine-grained performance analysis.
For example, here's the link:https://scans.gradle.com/s/u7uyv3vuyhrig/timeline[build timeline for the Groovy build]:

image:groovy-build-scan.png[]

You can use build scans to debug dependency resolution, Gradle task execution, and many other aspects of your build.

Once you've decided to go ahead with the migration, what should you do first? The best starting point is _recording the inputs and outputs_ of your Maven build, so that you can verify that your new Gradle build is functionally equivalent.


[[migmvn:automatic_conversion]]
== Performing an automatic conversion

Not only will the <<build_init_plugin#build_init_plugin,Gradle `init` task>> allow you to create a new skeleton project, but it will also automatically convert an existing Maven one to Gradle.
All you have to do is run the command

[listing.terminal]
----
$ gradle init
----

from the root project directory and let Gradle do its thing.
That basically consists of parsing the existing POMs and generating the corresponding Gradle build scripts.
Gradle will also create a settings script if you're migrating a <<multi_project_builds#multi_project_builds,multi-project build>>.

You'll find that the new Gradle build includes the following:

 * All the custom repositories that are specified in the POM
 * Your external and inter-project dependencies
 * The appropriate plugins to build the project (limited to one or more of the <<maven_plugin#maven_plugin,Maven>>, <<java_plugin#java_plugin,Java>> and <<war_plugin#war_plugin,War>> Plugins)
 
See the <<build_init_plugin#sec:pom_maven_conversion_,Build Init Plugin chapter>> for a complete list of the automatic conversion features.

One thing to bear in mind is that assemblies are not automatically converted.
They aren't necessarily problematic to convert, but you will need to do some manual work.

If you're lucky and don't have many plugins or much in the way of customisation in your Maven build, you can simply run

[listing.terminal]
----
$ gradle build
----

once the migration has completed.
This will run the tests and produce the required artifacts without any extra intervention on your part.

[[migmvn:migrating_deps]]
== Migrating dependencies

Gradle's dependency management system is more flexible than Maven's, but it still supports the same concepts of repositories, declared dependencies, scopes (<<managing_dependency_configurations#managing_dependency_configurations,dependency configurations>> in Gradle), and transitive dependencies.
In fact, Gradle works perfectly with Maven-compatible repositories, which makes it easy to migrate your dependencies.

NOTE: One notable difference between the two tools is in how they manage version conflicts. Maven uses a "closest" match algorithm, whereas Gradle picks the newest.
Don't worry though, you have a lot of control over which versions are selected, as documented in <<managing_transitive_dependencies#managing_transitive_dependencies,Managing Transitive Dependencies>>.

Over the following sections, we will show you how to migrate the most common elements of a Maven build's dependency management information.

[[migmvn:declaring_deps]]
=== Declaring dependencies

Gradle uses the same dependency identifier components as Maven: group ID, artifact ID and version.
It also supports classifiers.
So all you need to do is substitute the identifier information for a dependency into Gradle's syntax, which is described in the <<declaring_dependencies#declaring_dependencies,Declaring Dependencies>> chapter.

For example, consider this Maven-style dependency on Log4J:

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.12</version>
    </dependency>
</dependencies>
----

This dependency would look like the following in a Gradle build script:

[source,groovy]
----
dependencies {
    implementation 'log4j:log4j:1.2.12'  // <1>
}
----
<1> Attaches version 1.2.12 of Log4J to the `implementation` configuration (scope)

The string identifier takes the form "__<groupId>__:__<artifactId>__:__<version>__", although Gradle refers to them as "group", "module" and "version".

The above example raises an obvious question: what is that `implementation` configuration?
It's one of the standard dependency configurations provided by the <<java_plugin#tab:configurations,Java Plugin>> and is often used as a substitute for Maven's default `compile` scope.

Several of the differences between Maven's scopes and Gradle's standard configurations come down to Gradle distinguishing between the dependencies required to build a module and the dependencies required to build a module that depends on it.
Maven makes no such distinction, so published POMs typically include dependencies that consumers of a library don't actually need.

Here are the main Maven dependency scopes and how you should deal with their migration:

`compile`::
Gradle has two configurations that can be used in place of the `compile` scope: `implementation` and `api`.
The former is available to any project that applies the Java Plugin, while `api` is only available to projects that specifically apply the <<java_library_plugin#java_library_plugin,Java Library Plugin>>.

+
In most cases you should simply use the `implementation` configuration, but read the section on <<building_java_projects#sec:building_java_libraries,Building Java libraries>> and the chapter on the Java Library Plugin to find out whether you should use `api` instead for a given dependency.

`runtime`::
Use the `runtimeOnly` configuration.

`test`::
Gradle distinguishes between those dependencies that are required to _compile_ a project's tests and those that are only needed to _run_ them.
+
Dependencies required for test compilation should be declared against the `testImplementation` configuration.
Those that are only required for running the tests should use `testRuntimeOnly`.

`provided`::
Use the `compileOnly` configuration.
+
Note that the <<war_plugin#sec:war_dependency_management,War Plugin>> adds `providedCompile` and `providedRuntime` dependency configurations.
These behave slightly differently from `compileOnly` and simply ensure that those dependencies aren't packaged in the WAR file.
However, the dependencies are included on runtime and test runtime classpaths, so use these configurations if that's the behavior you need.

`import`::
The `import` scope can be used within both `<dependencyManagement>` and `<dependencies>` blocks.
If you're dealing with the former scenario, read the section on <<migmvn:using_boms,Using bills of materials>>.
+
The latter scenario has no equivalent in Gradle.
You can specify a regular dependency on the POM or its library, but the dependencies declared in the `<dependencies>` block will be treated as normal transitive dependencies of the build.
In other words, those dependencies in the POM will be mapped to the appropriate classpath based on the declared configuration.
+
For example, imagine you want to use the `groovy-all` POM for your tests.
It's solely a POM that has its own dependencies listed inside a `<dependencies>` block.
The appropriate configuration in the Gradle build looks like this:
+
[source,groovy]
----
dependencies {
    testCompile 'org.codehaus.groovy:groovy-all:2.5.4'
}
----
+
The result of this will be that all `compile` and `runtime` scope dependencies in the `groovy-all` POM get added to the test runtime classpath, while only the `compile` scope dependencies get added to the test compilation classpath.
Dependencies with other scopes will be ignored.

[[migmvn:declaring_repos]]
=== Declaring repositories

Gradle allows you to retrieve declared dependencies from any Maven-compatible or Ivy-compatible repository.
Unlike Maven, it has no default repository, so you have to declare at least one.
In order to have the same behavior as your Maven build, just configure <<repository_types#sub:maven_central,Maven Central>> in your Gradle build, like this:

[source,groovy]
----
repositories {
    mavenCentral()
}
----

You can also use the `repositories {}` block to configure custom repositories, as described in the <<repository_types#sub:maven_repo,Repository Types>> chapter.

[[migmvn:excluding_deps]]
=== Excluding transitive dependencies

Maven builds use exclusions to keep unwanted dependencies -- or unwanted _versions_ of dependencies -- out of the dependency graph.
These can be tricky to migrate not because Gradle doesn't have good support for such exclusions, but because you really need to understand _why_ an exclusion is in place to migrate it properly.

If you want to exclude a dependency for reasons unrelated to versions, then check out the section on <<managing_transitive_dependencies#sec:excluding_transitive_module_dependencies,Excluding transitive module dependencies>>.
It shows you how to attach an exclusion either to an entire configuration (often the most appropriate solution) or to a dependency.
You can even easily apply an exclusion to all configurations.

If you're more interested in controlling which version of a dependency is actually resolved, then Gradle has better options than exclusions.
Consider using <<managing_transitive_dependencies#sec:dependency_constraints,dependency constraints>> or <<managing_transitive_dependencies#sec:enforcing_dependency_version,forcing a particular version>>.

[[migmvn:optional_deps]]
=== Handling optional dependencies

There are two sides to optional dependencies: 

 * How the build treats them as transitive dependencies
 * How declared dependencies are published as optional

For the first scenario, Gradle simply ignores any transitive dependencies that are declared as optional.
They are not resolved and have no impact on the versions selected if the same dependencies appear elsewhere in the dependency graph as non-optional.

As for publishing dependencies as optional, Gradle has no built-in support at this time.
However, you can use the https://plugins.gradle.org/plugin/nebula.optional-base[Nebula Optional Base Plugin] to get the required behavior.

[[migmvn:using_boms]]
== Using bills of materials (BOMs)

Maven allows you to share dependency constraints by defining dependencies inside a `<dependencyManagement>` section of a POM file that has a packaging type of `pom`.
This special type of POM (a BOM) can then be imported into other POMs so that you have consistent library versions across your projects.

Gradle can use such BOMs for the same purpose, using a special dependency syntax based on link:{groovyDslPath}/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:platform(java.lang.Object)[platform()] and link:{groovyDslPath}/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:enforcedPlatform(java.lang.Object)[enforcedPlatform()] methods.
You simply declare the dependency in the normal way, but wrap the dependency identifier in the appropriate method, as shown in this example that "imports" the Spring Boot Dependencies BOM:

.Importing a BOM in a Gradle build
====
include::sample[dir="userguide/mavenMigration/importBom/groovy",files="build.gradle[tags=bom]"]
====
<1> Apply the Spring Boot Dependencies BOM
<2> Add a dependency whose version is defined by that BOM

You can learn more about this feature and the difference between `platform()` and `enforcedPlatform()` in the section on <<managing_transitive_dependencies#sec:bom_import,importing version recommendations from a Maven BOM>>.

NOTE: You can use this feature to apply the `<dependencyManagement>` information from any dependency's POM to the Gradle build, even those that don't have a packaging type of `pom`. However, `platform()` and `enforcedPlatform()` will ignore any dependencies declared in the `<dependencies>` block.

== Migrating multi-module builds (project aggregation)

Maven's multi-module builds map nicely to Gradle's <<multi_project_build#multi_project_build,multi-project builds>>.
Try the corresponding link:{guidesUrl}/creating-multi-project-builds/[tutorial] to see how a basic multi-project build is set up.

To migrate a multi-module Maven build, simply follow these steps:

 1. Create a settings script that matches the `<modules>` block of the root POM.
+
For example, this `<modules>` block:
+
[source,xml]
----
<modules>
    <module>simple-weather</module>
    <module>simple-webapp</module>
</modules>
----
+
can be migrated by adding the following line to the settings script:
+
[source,groovy]
.settings.gradle
----
include 'simple-weather', 'simple-webapp'
----
 2. Replace cross-module dependencies with <<dependency_types#sub:project_dependencies,project dependencies>>.
 3. Replicate project inheritance with <<multi_project_builds#sec:cross_project_configuration,cross-project configuration>>.
+
This basically involves creating a root project build script that injects shared configuration into the appropriate subprojects.

One notable feature that's missing is a standard way to share dependency versions across projects in a multi-project build.
A common approach is to use <<writing_build_scripts#sec:extra_properties,extra properties>> in the root build script to store the versions, since those properties are visible from subprojects as well.

== Migrating Maven profiles and properties

Maven allows you parameterize builds using properties of various sorts.
Some are read-only properties of the project model, others are user-defined in the POM.
It even allows you to treat system properties as project properties.

Gradle has a similar system of project properties, although it differentiates between those and system properties.
You can, for example, define properties in:

* the build file
* a `gradle.properties` file in the root project directory
* a `gradle.properties` file in the `$HOME/.gradle` directory

Those aren't the only options, so if you are interested in finding out more about how and where you can define properties, check out the <<build_environment#build_environment,Build Environment>> chapter.

One important piece of behavior you need to be aware of is what happens when the same property is defined in both the build file and one of the external properties files: the build file value takes precedence.
Always.
Fortunately, you can mimic the concept of profiles to provide overridable default values.

Which brings us on to Maven profiles.
These are a way to enable and disable different configurations based on environment, target platform, or any other similar factor.
Logically, they are nothing more than limited ‘if' statements.
And since Gradle has much more powerful ways to declare conditions, it does not need to have formal support for profiles (except in the POMs of dependencies).
You can easily get the same behavior by combining conditions with secondary build files, as you'll see next.

Let's say you have different deployment settings depending on environment: local development (the default), a test environment, and production.
To add profile-like behavior, first create build files for each environment in the project root: `profile-default.gradle`, `profile-test.gradle`, and `profile-prod.gradle`.
Next, add a condition similar to the following to the main build file:

[source,groovy]
----
if (!hasProperty('buildProfile')) ext.buildProfile = 'default'
apply from: "profile-${buildProfile}.gradle"
----

All you have to do then is put the environment-specific configuration, such as project properties, dependencies, etc., in the corresponding build file.
To activate a particular profile, you can just pass in the relevant project property on the command line:

[listing.terminal]
----
$ gradle -PbuildProfile=test build
----

Or you can set the project property another way.
It's up to you.
And those conditions don't just have to check project properties.
You could check environment variables, the JDK version, the OS the build is running on, and anything else you can imagine.

One thing to bear in mind is that high level ‘if' statements make builds harder to understand and maintain, similar to the way they complicate Object-Oriented code.
The same applies to profiles.
Gradle offers you many better ways to avoid the extensive use of profiles that Maven often requires, for example by offering variants.

For a lengthier discussion on working with Maven profiles in Gradle, look no further than http://gradle.org/feature-spotlight-gradles-support-maven-pom-profiles[this article] by Benjamin Muschko.


== Filtering resources

Maven has a phase called `process-resources` that has the goal `resources:resources` bound to it by default.
This gives the build author an opportunity to perform variable substitution on various files, such as web resources, packaged properties files, etc.

The Java plugin for Gradle provides a `processResources` task to do the same thing.
Here's an example configuration:

.Filtering resources via the `processResources` task
====
include::sample[dir="userguide/mavenMigration/resourceFiltering/groovy",files="build.gradle[tags=process-resources]"]
====

So the left hand side of each colon is the token name and the right hand side is a project property.
This variable substitution will apply to all your resource files (the ones under `src/main/resources` usually).

Gradle has other powerful ways for property processing.
You can hook in your own filter via a closure that allows you to process the content line by line, or you can add your own `FilterReader` implementation.
For more details, see the documentation for the link:{javadocPath}/org/gradle/api/file/ContentFilterable.html[ContentFilterable] interface which all copy and archive tasks implement.


== Configuring integration tests

Although unit tests are very useful, they can't ensure that an application or library works as a whole.
It's easy for bugs to appear in the interactions between objects and their interactions with the environment.
That's why many projects incorporate some form of higher level testing, sometimes termed integration, functional or acceptance testing.

Maven supports these types of test by providing an extra set of phases: `pre-integration-test`, `integration-test`, `post-integration-test`, and `verify`.
It also uses the Failsafe plugin rather than Surefire so that failed integration tests don't automatically fail the build (because you may need to clean up resources, such as a running application server).

Another factor to consider is where you keep your integration test classes.
The default approach is to mix them with your unit test classes, but this is less than ideal.
A common alternative is to use profiles so that you can keep the two types of test separate.

So how should you approach migrating such a setup to Gradle? Forget plugins: source sets are your friends in this situation.
A standard Java project already has two source sets for your main classes and your unit tests.
Why not add an extra one for integration tests? Or even more than one for different types of integration test? Say low-level tests against a live database and higher level tests with something like FitNesse.

By declaring a new source set, Gradle automatically sets you up with corresponding configurations (`[sourceSet]Compile` and `[sourceSet]Runtime`) as well as compilation tasks (`compile[SourceSet][Lang]`) and a resource processing task (`process[SourceSet]Resources`).
All you need to do is add a task to run the tests and ensure that the classpaths are all set up.
You might also want to add tasks for starting/stopping a database or application server if your tests require something like that.

Let's now take a look at an example so you can see what's involved in practice:

.Configuring a source set for integration tests
====
include::sample[dir="userguide/mavenMigration/integrationTests/groovy",files="build.gradle[tags=sourcesets]"]
====

In the above example, I create a new source set called `integTest`.
I also make sure that the application or library classes, as well as their dependencies, are included on the classpath when compiling the integration tests.

Your integration tests will probably use some third party libraries of their own, so you'll want to add those the compilation classpath too.
That's done in the normal way in the `dependencies` block:

.Adding dependencies for compiling and running integration tests
====
include::sample[dir="userguide/mavenMigration/integrationTests/groovy",files="build.gradle[tags=dependencies]"]
====

The integration tests will now compile, but there is currently no way to run them. That's where the custom `Test` task comes in:

.Creating a task that runs the integration tests
====
include::sample[dir="userguide/mavenMigration/integrationTests/groovy",files="build.gradle[tags=testtask]"]
====

In the above example, I'm assuming that the integration tests run against an application server that needs to be started and shut down at the appropriate times.
You can learn more about how and what to configure on the `Test` task in Gradle's link:{groovyDslPath}/org.gradle.api.tasks.testing.Test.html[DSL Reference].

All that's left to do at this point is incorporate the `integTest` task into your task graph, for example by having `build` depend on it.
It's really up to you how you fit it into the build.
If you want to support other test types, just rinse and repeat.


== Migrating common plugins

Maven and Gradle share a common approach of extending the build through plugins.
Although the plugin systems are very different beneath the surface, they share many feature-based plugins, such as:

* Shade/Shadow
* Jetty
* Checkstyle
* JaCoCo
* AntRun (see further down)

Why does this matter? Because many plugins rely on standard Java conventions, so migration is just a matter of replicating the configuration of the Maven plugin in Gradle.
As an example, here's a simple Maven Checkstyle plugin configuration:

[source,xml]
----
...
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-checkstyle-plugin</artifactId>
  <version>2.17</version>
  <executions>
    <execution>
      <id>validate</id>
      <phase>validate</phase>
      <configuration>
        <configLocation>checkstyle.xml</configLocation>
        <encoding>UTF-8</encoding>
        <consoleOutput>true</consoleOutput>
        <failsOnError>true</failsOnError>
        <linkXRef>false</linkXRef>
      </configuration>
      <goals>
        <goal>check</goal>
      </goals>
    </execution>
  </executions>
</plugin>
...
----

Everything outside of the configuration block can safely be ignored when migrating to Gradle.
In this case, the corresponding Gradle configuration looks like the following:

.Configuring the Gradle Checkstyle Plugin
====
include::sample[dir="userguide/mavenMigration/checkstyle/groovy",files="build.gradle[tags=checkstyle]"]
====

The Checkstyle tasks are automatically added as dependencies of the `check` task, which also includes `test`.
If you want to ensure that Checkstyle runs before the tests, then just specify an ordering with the mustRunAfter() method:

.Controlling when the `checkstyle` task runs
====
include::sample[dir="userguide/mavenMigration/checkstyle/groovy",files="build.gradle[tags=dependsOn]"]
====

As you can see, the Gradle configuration is often much shorter than the Maven equivalent.
You also have a much more flexible execution model since we are not longer constrained by Maven's fixed phases.

While migrating a project from Maven, don't forget about source sets.
These often provide a more elegant solution for handling integration tests or generated sources than Maven can provide, so you should factor them into your migration plans.


=== Ant goals

Many Maven builds rely on the AntRun plugin to customize the build without the overhead of implementing a custom Maven plugin.
Gradle has no equivalent plugin because Ant is a first-class citizen in Gradle builds, via the `ant` object.
For example, you can use Ant's Echo task like this:

.Invoking Ant tasks
====
include::sample[dir="userguide/mavenMigration/ant/groovy",files="build.gradle"]
====

Even Ant properties and filesets are supported natively.
To learn more, see <<ant#ant,Using Ant from Gradle>>.


== Understanding which plugins you don't need

It's worth remembering that Gradle builds are typically easier to extend and customize than Maven.
In this context, that means you may not need a Gradle plugin to replace a Maven one.
For example, the Maven Enforcer plugin allows you to control dependency versions and environmental factors, but these things can easily be configured in a normal Gradle build script.


== Dealing with uncommon and custom plugins

You may come across Maven plugins that have no counterpart in Gradle, particularly if you or someone in your organisation has written a custom plugin.
Such cases rely on you understanding how Gradle (and potentially Maven) works, because you will usually have to write your own plugin.

For the purposes of migration, there are two key types of Maven plugin:

* Those that use the Maven project object.
* Those that don't.

Why is this important? Because if you use one of the latter, you can trivially reimplement it as a Gradle task.
Simply define task inputs and outputs to correspond to the mojo parameters and convert the execution logic into a task action.

If a plugin depends on the Maven project, then you will have to rewrite it.
Don't start by considering how the Maven plugin works, but look at what problem it is trying to solve.
Then try to work out how to solve that problem in Gradle.
You'll probably find that the two build models are different enough that "transcribing" Maven plugin code into a Gradle plugin just won't be effective.
On the plus side, the plugin is likely to be much easier to write than the original Maven one because Gradle has a much richer build model.

If you do need to implement custom logic, either via build files or plugins, then be sure to familiarize yourself with Gradle's link:{groovyDslPath}/[Groovy DSL Reference], which provides comprehensive documentation on the API that you'll be working with.
It details the standard configuration blocks (and the objects that back them), the core types in the system (`Project`, `Task`, etc.), and the standard set of tasks.
The main entry point is the `Project` interface as that's the top-level object that backs the build files.
