// Copyright 2017 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[working_with_files]]
== Working With Files

Almost every Gradle build works with files: think source files, library dependencies, reports and so on. That's why Gradle comes with a comprehensive API that makes it simple to achieve common tasks.

The API has two parts to it:

 * Specifying which files and directories to process
 * Specifying what to do with them

We look at these parts in more detail later in the chapter, but we'll start with how you accomplish some of the most common tasks users need.

=== Copying a single file

You copy a file by creating an instance of Gradle's builtin api:org.gradle.api.tasks.Copy[] task and configuring it with the location of the file and where you want to put it. This example mimics copying a generated report into a directory that will be packed into an archive (zip, tarball, or whatever):

----
task copyReport(type: Copy) {
    from file("${buildDir}/reports/my-report.pdf")
    into file("${buildDir}/toArchive")
}
----

The api:org.gradle.api.Project#file(java.lang.Object)[file()] method is used to create a file or directory path relative to the current project and is a common way to locate files in the project directory.

You can even use the path directly without the `file()` method:

----
task copyReport(type: Copy) {
    from "${buildDir}/reports/my-report.pdf"
    into "${buildDir}/toArchive"
}
----

TODO: Link this to a later section that explains how this implicit file path works

Note that hardcoding paths like this makes the build brittle. It's better to use the task that generates a file as the source of the file's location. In this modified example, we use a report task defined elsewhere that has the report's location stored in the `outputFile` property:

----
ext.archiveDir = file("${buildDir}/toArchive")

task copyReport(type: Copy) {
    from myReportTask.outputFile
    into archiveDir
}
----

We also moved the hardcoded archive directory into a project property, which only needs to be changed in one place to apply to the whole build.

TODO: Link to more detailed coverage of `from()` arguments

=== Copying multiple files

You can extend the previous examples to multiple files very easily by providing multiple arguments to `from()`:

----
task copyReports(type: Copy) {
    from "${buildDir}/reports/my-report.pdf", "src/docs/manual.pdf"
    into "${buildDir}/toArchive"
}
----

Now two files are copied into the archive directory.

What if you want to copy all the PDFs in a directory without having to specify each one? You can easily attach both inclusion and exclusion patterns to the copy specification. Here we use a pattern to include only PDFs:

----
task copyReports(type: Copy) {
    from "${buildDir}/reports"
    include "*.pdf"
    into "${buildDir}/toArchive"
}
----

One thing to note in this example is that only PDFs directly in the `reports` directory are copied. If there are PDFs in subdirectories of `reports`, they'll be left out. You can change that by using an Ant-style glob pattern:

----
task copyReports(type: Copy) {
    from "${buildDir}/reports"
    include "**/*.pdf"
    into "${buildDir}/toArchive"
}
----

This approach has the side effect of copying the directory structure below `reports` as well as the files. This may be what you want. It may not be. Copying files includes many such decisions and there are too many to cover here, but know that there are very few requirements that can't be handled elegantly by Gradle copy specifications.

Head over to ~TODO~ in order to learn all the different options available for getting the exact behavior you want.

=== Copying directory hierarchies

You may have the need to copy not just files, but the directory structure they reside in as well. This is, in fact, the default behavior when you specify a directory as the `from()` argument. So the following will copy everything in the `reports` directory, including all its subdirectories:

----
task copyReports(type: Copy) {
    from "${buildDir}/reports"
    into "${buildDir}/toArchive"
}
----

The key aspect that users struggle with is controlling how much of the directory structure goes to the destination. In the above example, do you get a `toArchive/reports` directory or does everything in `reports` go straight into `toArchive`? The answer is the latter. If a directory is part of the `from()` path, then it *won't* appear in the destination.

So how do you ensure that `reports` itself is copied across, but not any other directory in `$buildDir`? The answer is to add it as an include pattern:

----
task copyReports(type: Copy) {
    from("${buildDir}") {
        include "reports/**"
    }
    into "${buildDir}/toArchive"
}
----

You'll get the same behavior as before except with one extra level of directory in the destination, i.e. `toArchive/reports`.

One thing to note is how the `include()` directive applies only to the `from()`, whereas the directive in the previous section applied to the whole task. These different levels of granularity in the copy specification allow you to easily handle most requirements that you will come across. TODO: Link to more details on copy specs.

=== Creating archives (zip, tar, etc.)

From the perspective of Gradle, packing files into a single archive is effectively a copy in which the destination is an archive file instead of a directory on the file system. This means that archiving files looks a lot like copying, with all of the same features!

The simplest case involves packing all the contents of a directory into an archive, such as a zip in this example:

----
task packageDistribution(type: Zip) {
    archiveName = "my-distribution.zip"
    destinationDir = file("${buildDir}/dist")

    from "${buildDir}/toArchive"
}
----

Each type of archive has its own task type, the most common ones being api:org.gradle.api.tasks.bundling.Zip[], api:org.gradle.api.tasks.bundling.Tar[] and api:org.gradle.api.tasks.bundling.Jar[]. And instead of having an `into()` setting like `Copy`, you configure the location and name of the destination archive file. In many cases you don't even need to do that as `destinationDir` defaults to `${buildDir}/distributions` and many plugins provide conventions for `archiveName`.

The archiving tasks share most of the configuration options of `Copy`, including filtering and renaming. One of the most common options people use allows you to create a subdirectory in the destination to copy the files into. For example, let's say you want to package all PDFs into a `docs` directory in the root of the archive. This `docs` directory doesn't exist in the source location, so you have to create it as part of the archive. You do this by adding an `into()` declaration for just the PDFs:

----
task packageDistribution(type: Zip) {
    archiveName = "my-distribution.zip"
    destinationDir = file("${buildDir}/dist")

    from("${buildDir}/toArchive") {
        exclude "**/*.pdf"
    }

    from("${buildDir}/toArchive") {
        include "**/*.pdf"
        into "docs"
    }
}
----

As you can see, you can have multiple `from()` declarations in a copy specification, each with its own configuration.

[[sec:unpacking_archives_example]]
=== Unpacking archives

Archives are effectively self-contained file systems, so unpacking them is a case of copying the files from that file system into a directory (or even another archive). Gradle enables this by providing some wrapper functions that make archives available as hierarchical collections of files known as file trees (TODO: link to an in-depth discussion of file trees).

The two functions of interest are api:org.gradle.api.Project#zipTree[] and api:org.gradle.api.Project#tarTree[], which produce a api:org.gradle.api.file.FileTree[] from a corresponding archive file. That file tree can then be used in a `from()` specification, like so:

----
task unpackFiles(type: Copy) {
    from zipTree("src/resources/thirdPartyResources.zip")
    into "${buildDir}/resources"
}
----

As with a normal copy, you can control which files are unpacked via filters and even rename files as they are unpacked.

[[sec:creating_archives_example]]
=== Creating directories

Many tasks need to create directories to store the files they generate, which is why Gradle automatically manages this aspect of tasks when they explicitly define file and directory outputs. You can learn about this feature in the <<sec:up_to_date_checks,incremental build>> section of the user guide. All core Gradle tasks ensure that any output directories they need are created if necessary using this mechanism.

In cases where you need to create a directory manually, you can use the api:org.gradle.api.Project#mkdir[] method from within your build scripts or custom task implementations. Here's a simple example:

----
task ensureDirectory {
    doLast {
        mkdir "images"
    }
}
----

[[sec:moving_files_example]]
=== Moving files and directories

Gradle has no API for moving files and directories around, but you can use the <<sec:ant,Apache Ant integration>> to easily do that, as shown in this example:

----
task moveReports {
    doLast {
        ant.move file: "${buildDir}/reports", todir: "${buildDir}/toArchive"
    }
}
----

This is not a common requirement and should be used sparingly as you lose information and can easily break a build. It's generally preferable to copy directories and files instead.

[[sec:renaming_files_example]]
=== Renaming files on copy

The files used and generated by your builds sometimes don't have names that suit, for whatever reason, so when you copy them you want to modify those names. Gradle allows you to do this as part of a copy specification using the `rename()` configuration.

The following example removes the "-staging-" marker from the names of any files that include it in a Java web application:

----
task rename(type: Copy) {
    from "src/main/webapp"
    into "${buildDir}/explodedWar"

    rename '(.+)-staging-(.+)', '$1$2'
}
----

You can use regular expressions for this, as in the above example, or closures that use more complex logic to determine the target filename. For example, the following task truncates filenames:

----
task copyWithTruncate(type: Copy) {
    from "${buildDir}/reports"
    rename { String filename ->
        if (filename.size() > 10) {
            return filename[0..7] + "~" + filename.size()
        }
        else return filename
    }
    into "${buildDir}/toArchive"
}
----

As with filtering, you can also apply renaming to a subset of files to copy by configuring it on a `from()` instead of at the task level.

[[sec:locating_files]]
=== File paths in depth

In order to perform some action on a file, you need to know where it is, and that's the information provided by file paths. Gradle builds on the standard Java `java.io.File` class, which represents the location of a single file, and provides new APIs for dealing with collections of paths. This section shows you how to use the Gradle APIs to specify file paths that tasks can use.

[[sec:single_file_paths]]
==== Single file paths

One of the great quandaries when developing a build is how to specify file locations when the build may be executed from an arbitrary directory — not necessarily in the project — and may be run on any number of different systems with incompatible directory layouts. The standard Java mechanism for specifying a file path runs into trouble in these situations:

 * `new File(relative path)` generates a path relative to the current working directory, which could be anywhere
 * `new File(absolute path)` will fail if the file system doesn't have the requisite path.

Gradle solves this problem by providing the api:org.gradle.api.Project#file(java.lang.Object)[] method, which generates a path relative to the _project_ directory (unless the given path is absolute, in which case it is used as is). Here are some examples of using the `file()` method with different types of argument:

++++
<sample id="resolveFile" dir="userguide/files/file" title="Locating files">
    <sourcefile file="build.gradle" snippet="simple-params"/>
</sample>
++++

As you can see, you can pass strings, `File` instances and `Path` instances to the `file()` method, all of which result in an absolute `File` object. You can find other options for argument types in the reference guide, linked in the previous paragraph.

What happens in the case of multi-project builds? The `file()` method will always turn relative paths into paths that are relative to the current project directory, which may be a child project. If you want to use a path that's relative to the _root project_ directory, then you need to use the special api:org.gradle.api.Project#getRootDir()[] property to construct an absolute path, like so:

----
File configFile = file("${rootDir}/shared/config.xml")
----

Let's say you're working on a multi-project build in a `dev/projects/AcmeHealth` directory. You use the above example in the build of the library you're fixing — at `AcmeHealth/subprojects/AcmePatientRecordLib/build.gradle`. The file path will resolve to the absolute version of `dev/projects/AcmeHealth/shared/config.xml`.

The `file()` method can be used to configure any task that has a property of type `File`. Many tasks, though, work on multiple files, so we look at how to specify sets of files next.

[[sec:file_collections]]
==== File collections

A _file collection_ is simply a set of file paths that's represented by the api:org.gradle.api.file.FileCollection[] interface. _Any_ file paths. It's important to understand that the file paths don't have to be related in any way, so they don't have to be in the same directory or even have a shared parent directory. You will also find that many parts of the Gradle API use `FileCollection`, such as the copying API discussed later in this chapter and <<sub:configurations,dependency configurations>>.

The recommended way to specify a collection of files is to use the api:org.gradle.api.Project#files(java.lang.Object...)[] method, which returns a `FileCollection` instance. This method is very flexible and allows you to pass multiple strings, `File` instances, collections of strings, collections of `File`s, and more. You can even pass in tasks if they have <<sec:task_inputs_outputs,defined outputs>>. Learn about all the supported argument types in the reference guide.

As with the api:org.gradle.api.Project#file(java.lang.Object)[] method covered in the <<sec:single_file_paths,previous section>>, all relative paths are evaluated relative to the current project directory. The following example demonstrates some of the variety of argument types you can use, using strings, `File` instances, a list and a `Path`:

++++
<sample id="fileCollections" dir="userguide/files/fileCollections" title="Creating a file collection">
    <sourcefile file="build.gradle" snippet="simple-params"/>
</sample>
++++

File collections have some important attributes in Gradle. They can be:

 * created lazily
 * iterated over
 * filtered
 * combined

_Lazy creation_ of a file collection is useful when you need to evaluate the files that make up a collection when the build runs. In the following example, we query the file system to find out what files exist in a particular directory and make them a file collection:

++++
<sample id="fileCollections" dir="userguide/files/fileCollections" title="Implementing a file collection">
    <sourcefile file="build.gradle" snippet="closure"/>
    <output args="-q list"/>
</sample>
++++

The key to lazy creation is passing a closure to the `files()` method. Your closure simply needs to return a value of a type accepted by `files()`, such as `List<File>`, `String`, `FileCollection`, etc.

_Iterating over a file collection_ can be done through the `each()` method on the collection or using the collection in a `for` loop. In both approaches, the file collection is treated as a set of `File` instances, i.e. your iteration variable will be of type `File`.

The following example demonstrates such iteration as well as how you can convert file collections to other types using the `as` operator or supported properties:

++++
<sample id="fileCollections" dir="userguide/files/fileCollections" title="Using a file collection">
    <sourcefile file="build.gradle" snippet="usage"/>
    <test args="-q usage"/>
</sample>
++++

You can also see at the end of the example _how to combine file collections_ using the `+` and `-` operators to merge and subtract them. An important feature of the resulting file collections is that they are _live_. In other words, when you combine file collections in this way, the result always reflects what's in the original file collections, even if they change during the build.

For example, imagine `collection` in the above example gains an extra file or two after `union` is created. As long as you use `union` after those files are added to `collection`, `union` will also contain those additional files. The same goes for the `different` file collection.

Live collections are also important when it comes to _filtering_. If you want to use a subset of a file collection, you can take advantage of the api:org.gradle.api.file.FileCollection#filter(org.gradle.api.specs.Spec)[] method to determine which files to "keep". In the following example, we create a new collection that consists of only the files that end with .txt in the source collection:

----
FileCollection textFiles = collection.filter { File f ->
    f.name.endsWith(".txt")
}
----

If `collection` changes at any time, either by adding or removing files from itself, then `textFiles` will immediately reflect the change because it is also a live collection. Note that the closure you pass to `filter()` takes a `File` as an argument and should return a boolean.

[[sec:file_trees]]
==== File trees

A _file tree_ is a file collection that retains the directory structure of the files it contains and has the type api:org.gradle.api.file.FileTree[]. This means that all the paths in a file tree must have a shared parent directory. The following diagram highlights the distinction between file trees and file collections in the common case of copying files:

++++
<figure>
    <title>The differences in how file trees and file collections behave when copying files</title>
    <imageobject>
        <imagedata fileref="img/file-collection-vs-file-tree.png" width="160mm"/>
    </imageobject>
</figure>
++++

NOTE: Although `FileTree` extends `FileCollection` (an is-a relationship), their behaviors do differ. In other words, you can use a file tree wherever a file collection is required, but remember: a file collection is a flat list/set of files, while a file tree is a file and directory hierarchy. To convert a file tree to a flat collection, use the api:org.gradle.api.file.FileTree#getFiles()[] property.

The simplest way to create a file tree is to pass a file or directory path to the api:org.gradle.api.Project#fileTree(java.lang.Object)[] method. This will create a tree of all the files and directories in that base directory (but not the base directory itself). The following example demonstrates how to use the basic method and, in addition, how to filter the files and directories using Ant-style patterns:

++++
<sample id="fileTrees" dir="userguide/files/fileTrees" title="Creating a file tree">
    <sourcefile file="build.gradle" snippet="define"/>
</sample>
++++

You can see more examples of supported patterns in the API docs for api:org.gradle.api.tasks.util.PatternFilterable[]. Also, see the API documentation for `fileTree()` to see what types you can pass as the base directory.

[NOTE]
====
By default, the `FileTree` instance `fileTree()` returns will apply some Ant-style default exclude patterns for convenience. For the complete default exclusion list, see http://ant.apache.org/manual/dirtasks.html#defaultexcludes[Default Excludes].
====

You can do many of the same things with file trees that you can with file collections:

 * iterate over them (depth first)
 * filter them (using api:org.gradle.api.file.FileTree#matching(org.gradle.api.Action)[] and Ant-style patterns)
 * merge them

You can also traverse file trees using the api:org.gradle.api.file.FileTree#visit(org.gradle.api.Action)[] method. All of these techniques are demonstrated in the following example: 

++++
<sample id="fileTrees" dir="userguide/files/fileTrees" title="Using a file tree">
    <sourcefile file="build.gradle" snippet="use"/>
</sample>
++++

We've discussed how to create your own file trees and file collections, but it's also worth bearing in mind that many Gradle plugins provide their own instances of file trees, such as <<sec:java_source_sets,Java's source sets>>. These can be used and manipulated in exactly the same way as the file trees you create yourself.

Another specific type of file tree that users commonly need is the archive, i.e. ZIP files, TAR files, etc. We look at those next.

[[sec:archive_contents]]
==== Using archives as file trees

An archive is a directory and file hierarchy packed into a single file. In other words, it's a special case of a file tree, and that's exactly how Gradle treats archives. Instead of using the `fileTree()` method, which only works on normal file systems, you use the api:org.gradle.api.Project#zipTree[] and api:org.gradle.api.Project#tarTree(java.lang.Object)[] methods to wrap archive files of the corresponding type (note that JAR, WAR and EAR files are ZIPs). Both methods return `FileTree` instances that you can then use in the same way as normal file trees. For example, you can extract some or all of the files of an archive by copying its contents to some directory on the file system. Or you can merge one archive into another.

Here are some simple examples of creating archive-based file trees:

++++
<sample id="fileTrees" dir="userguide/files/fileTrees" title="Using an archive as a file tree">
    <sourcefile file="build.gradle" snippet="archive-trees"/>
</sample>
++++

You can see a practical example of extracting an archive file <<sec:unpacking_archives_example,earlier in the chapter>>.

[[sec:specifying_multiple_files]]
==== Understanding implicit conversion to file collections

TODO: Review this section for accuracy

Many objects in Gradle have properties which accept a set of input files. For example, the api:org.gradle.api.tasks.compile.JavaCompile[] task has a `source` property, which defines the source files to compile. You can set the value of this property using any of the types supported by the <<sec:file_collections,files()>> method, which was shown above. This means you can set the property using, for example, a `File`, `String`, collection, `FileCollection` or even a closure. Here are some examples:

++++
<sample id="inputFiles" dir="userguide/files/inputFiles" title="Specifying a set of files">
    <sourcefile file="build.gradle" snippet="set-input-files"/>
</sample>
++++

Usually, there is a method with the same name as the property, which appends to the set of files. Again, this method accepts any of the types supported by the <<sec:file_collections,files()>> method.

++++
<sample id="inputFiles" dir="userguide/files/inputFiles" title="Appending a set of files">
    <sourcefile file="build.gradle" snippet="add-input-files"/>
</sample>
++++


[[sec:copying_files]]
=== File copying in depth

The basic process of copying files in Gradle is a simple one:

 * Define a task of type api:org.gradle.api.tasks.Copy[]
 * Specify which files (and potentially directories) to copy
 * Specify where a destination to copy the files to

But this apparent simplicity hides a rich API that allows fine-grained control of which files are copied, where they go, and what happens to them as they are copied (renaming and token substitution are both possibilities).

Let's start with the last two items on the list, which form what is known as a _copy specification_. This is formally based on the api:org.gradle.api.file.CopySpec[] interface, which the `Copy` task implements, and offers:

 * A api:org.gradle.api.file.CopySpec#from(java.lang.Object...)[] method to define what to copy
 * An api:org.gradle.api.file.CopySpec#into(java.lang.Object)[] method to define the destination

`CopySpec` has several additional methods that allow you to control the copying process, but these two are the only required ones. `into()` is straightforward, requiring a directory path as its argument in any form supported by the api:org.gradle.api.Project#file(java.lang.Object)[] method. The `from()` configuration is far more flexible.

Not only does `from()` accept multiple arguments, it also allows several different types of argument. For example, some of the most common types are:

 * A `String` — treated as a file path or, if it starts with "file://", a file URI
 * A `File` — used as a file path
 * A `FileCollection` or `FileTree` — all files in the collection are included in the copy
 * A task — the files or directories that form a task's <<sec:task_inputs_outputs,defined outputs>>

In fact, `from()` accepts all the same arguments as api:org.gradle.api.Project#files(java.lang.Object...)[], so see that method for a more detailed list of acceptable types.

Something else to consider is what type of thing a file path refers to:

 * A file is copied as is
 * A directory is effectively treated as a file tree: everything in it, including subdirectories, is copied. However, the directory itself is not included in the copying.
 * If the path doesn't exist, it is ignored

Here is an example that uses multiple `from()` specifications, each with a different argument type. You will probably also notice that `into()` is configured lazily using a closure — a technique that also works with `from()`:

++++
<sample id="copy" dir="userguide/files/copy" title="Specifying copy task source files and destination directory">
    <sourcefile file="build.gradle" snippet="copy-task-2"/>
</sample>
++++

You can find more simple examples of using the `Copy` task at the beginning of the chapter. Some of them make use of another aspect of copy specifications for further control over what gets copied: inclusions and exclusions.

==== Filtering files

You've already seen that you can filter file collections and file trees, which you can use directly in a `Copy` task, but you can also apply filtering in the copy specification through the api:org.gradle.api.file.CopySpec#include(java.lang.String...)[] and api:org.gradle.api.file.CopySpec#exclude(java.lang.String...)[] methods.

Both of these methods are normally used with Ant-style include or exclude patterns, as described in api:org.gradle.api.tasks.util.PatternFilterable[]. You can also perform more complex logic by using a closure that takes a api:org.gradle.api.file.FileTreeElement[] and returns `true` if the file should be included or `false` otherwise. The following example demonstrates both forms, ensuring that only .html and .jsp files are copied, except for those .html files with the word "staging" in their content:

++++
<sample id="copy" dir="userguide/files/copy" title="Selecting the files to copy">
    <sourcefile file="build.gradle" snippet="copy-task-with-patterns"/>
</sample>
++++

A question you may ask yourself at this point is what happens when inclusion and exclusion patterns overlap? Which pattern wins? Here are the basic rules:

 * If there are no explicit inclusions or exclusions, everything is included
 * If at least one inclusion is specified, only files and directories matching the patterns are included
 * Any exclusion pattern overrides any inclusions, so if a file or directory matches at least one exclusion pattern, it won't be included, regardless of the inclusion patterns

Bear these rules in mind when creating combined inclusion and exclusion specifications so that you end up with the exact behavior you want.

Note that the inclusions and exclusions in the above example will apply to _all_ `from()` configurations. If you want to apply filtering to a subset of the copied files, you'll need to use _<<sec:using_the_copyspec_class,child specifications>>_.

[[sec:renaming_files]]
==== Renaming files

The <<sec:renaming_files_example,example of how to rename files on copy>> earlier in the chapter gives you most of the information you need to perform this operation. It demonstrates the two options for renaming:

 * Using a regular expression
 * Using a closure

Regular expressions are a flexible approach to renaming, particularly as Gradle supports regex groups that allow you to remove and replaces parts of the source filename. The following example shows how you can remove the string '-staging-' from any filename that contains it using a simple regular expression:

++++
<sample id="renameOnCopy" dir="userguide/files/copy" title="Renaming files as they are copied">
    <sourcefile file="build.gradle" snippet="rename-files"/>
</sample>
++++

You can use any regular expression supported by the Java `{javaApi}/java/util/regex/Pattern.html[Pattern]` class and the substitution string (the second argument of `rename()` works on the same principles as the `{javaApi}/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-[Matcher.appendReplacement()]` method.

.Regular expressions in Groovy build scripts
[NOTE]
====
There are two common issues people come across when using regular expressions in this context:

 1. If you use a slashy string (those delimited by '/') for the first argument, you _must_ include the parentheses for `rename()` as shown in the above example.
 2. It's safest to use single quotes for the second argument, otherwise you need to escape the '$' in group substitutions, i.e. `"\$1\$2"`

The first is a minor inconvenience, but slashy strings have the advantage that you don't have to escape backslash ('\') characters in the regular expression. The second issue stems from Groovy's support for embedded expressions using `${ }` syntax in double-quoted and slashy strings.
==== 

The closure syntax for `rename()` is straightforward and can be used for any requirements that simple regular expressions can't handle. You're given the name of a file and you return a new name for that file, or `null` if you don't want to change the name. Do be aware that the closure will be executed for every file that's copied, so try to avoid expensive operations where possible.

The example above shows an example that can be handle by a regular expression, but you might want to use it for truncating filenames, converting them to uppercase, adding a date string, etc.

[[sec:filtering_files]]
==== Filtering file content (token substitution, templating, etc.)

Not to be confused with filtering which files are copied, _file content filtering_ allows you to transform the content of files while they are being copied. This can involve basic templating that uses token substitution, removal of lines of text, or even more complex filtering using a full-blown template engine.

The following example demonstrates several forms of filtering, including token substitution using the api:org.gradle.api.file.CopySpec#expand(java.util.Map)[] method and another using api:org.gradle.api.file.CopySpec#filter(java.lang.Class)[] with an https://ant.apache.org/manual/Types/filterchain.html[Ant filter]:

++++
<sample id="filterOnCopy" dir="userguide/files/copy" title="Filtering files as they are copied">
    <sourcefile file="build.gradle" snippet="filter-files"/>
</sample>
++++

The `filter()` method has two variants that behave differently:

 * one that takes a `{javaApi}/java/io/FilterReader.html[FilterReader] and is designed to work with Ant filters, such as `ReplaceTokens`
 * one that takes a closure or `Transformer` that defines the transformation for each line of the source file

Note that both variants assume the source files are text based. When you use the `ReplaceTokens` class with `filter()`, the result is a template engine that replaces tokens of the form `@tokenName@` (the Apache Ant-style token) with values that you define.

The `expand()` method treats the source files as http://docs.groovy-lang.org/latest/html/api/groovy/text/SimpleTemplateEngine.html[Groovy templates], which evaluate and expand expressions of the form `${expression}`. You can pass in property names and values that are then expanded in the source files. `expand()` allows for more than basic token substitution as the embedded expressions can be more than property names — they are full-blown Groovy expressions.

NOTE: It's good practice to specify the character set to use when reading and writing the file, otherwise the transformations won't work propery for non-ASCII text. You configure the character set with the `filteringCharset` property. If it's not specified, the JVM default character set is used, which is likely to be different from the one you want.

[[sec:using_the_copyspec_class]]
==== Using the `CopySpec` class

A copy specification (or copy spec for short) determines what gets copied to where, and what happens to files during the copy (renaming and content filtering). That should be clear already. But copy specs have two attributes that are worth covering in more detail:

 1. They are independent of tasks
 2. They are hierarchical

The first of these is fundamental in allowing you to _share copy specs within a build_. The second provides fine-grained control within the overall copy specification.

===== Sharing copy specs

Consider a scenario in which you want to copy static website resources in multiple situations in a build and perhaps pack them into archives. Each time this occurs, you want to make sure that only HTML and image files should be included (to keep the example simple). You can manually specify the appropriate inclusions each time they are needed, but this is a recipe for inconsistency and human error.

Instead, Gradle allows you to create standalone, reusable copy specs using the api:org.gradle.api.Project#copySpec(org.gradle.api.Action)[] method. The following example shows you how to create such a copy spec and use it in multiple copying-based tasks:

----
def webAssetsSpec = copySpec {
    include '**/*.html', '**/*.png', '**/*.jpg'
}

task copyAssets(type: Copy) {
    into "${buildDir}/explodedWar"
    with webAssetsSpec
}

task archiveApp(type: Zip) {
    from "otherResources"
    with webAssetsSpec
}
----

As you can see, the api:org.gradle.api.file.CopySpec#with(org.gradle.api.file.CopySpec...)[] method is the key to incorporating an existing copy specification into another one.

===== Using child specifications

If you only use a single copy spec, the file filtering and renaming will apply to _all_ the files that are copied. Sometimes this is what you want, but not always. Consider the following example that copies files into a directory structure that can be used by a Java Servlet container to deliver a website:

++++
<figure>
    <title>Creating an exploded WAR for a Servlet container</title>
    <imageobject>
        <imagedata fileref="img/exploded-war-child-copy-spec-example.png" width="160mm"/>
    </imageobject>
</figure>
++++

This is not a straightforward copy as the `WEB-INF` directory and its subdirectories don't exist within the project, so they must be created during the copy. In addition, we only want HTML and image files going directly into the root folder — `build/explodedWar` — and only JavaScript files going into the `js` directory. So we need separate filter patterns for those two sets of files.

The solution is to use _child specifications_, which can be applied to both `from()` and `into()` declarations. The following task definition does the necessary work:

++++
<sample id="nestedCopySpecs" dir="userguide/files/copy" title="Nested copy specs">
    <sourcefile file="build.gradle" snippet="nested-specs"/>
</sample>
++++

Notice how the `src/dist` configuration has a nested inclusion specification: that's the child copy spec. You can of course add content filtering and renaming here as required. A child copy spec is still a copy spec.

The above example also demonstrates how you can copy files into a subdirectory of the destination either by using a child `into()` on a `from()` or a child `from()` on an `into()`. Both approaches are acceptable, but you may want to create and follow a convention to ensure consistency across your build files.

[NOTE]
Don't get your `into()` specifications mixed up! For a normal copy — one to the filesystem rather than an archive — there should always be _one_ "root" `into()` that simply specifies the overall destination directory of the copy. Any other `into()` should have a child spec attached and its path will be relative to the root `into()`.

One final thing to be aware of is that a child copy spec inherits its destination path, include patterns, exclude patterns, copy actions, name mappings and filters from its parent. So be careful where you place your configuration.

[[sec:project_copy_method]]
==== Copying files in your own tasks

There might be occasions when you want to copy files or directories _as part of a task_. For example, a custom archiving task based on an unsupported archive format might want to copy files to a temporary directory before they are then archived. You still want to take advantage of Gradle's copy API, but without introducing an extra `Copy` task.

The solution is to use the api:org.gradle.api.Project#copy(org.gradle.api.Action)[] method. It works the same way as the `Copy` task by configuring it with a copy spec. Here's a trivial example:

++++
<sample id="copy" dir="userguide/files/copy" title="Copying files using the copy() method without up-to-date check">
    <sourcefile file="build.gradle" snippet="copy-method"/>
</sample>
++++

The above example demonstrates the basic syntax and also highlights two major limitations of using the `copy()` method.

First, the `copy()` method is not <<sec:up_to_date_checks,incremental>>. The example's `copyMethod` task will _always_ execute because it has no information about what files make up the task's inputs. You have to manually define the task inputs and outputs.

Second, using a task as a copy source, i.e. as an argument to `from()`, won't set up an automatic task dependency between your task and that copy source. As such, if you are using the `copy()` method as part of a task action, you must explicitly declare all inputs and outputs in order to get the correct behavior, as shown in this example:

++++
<sample id="copy" dir="userguide/files/copy" title="Copying files using the copy() method with up-to-date check">
    <sourcefile file="build.gradle" snippet="copy-method-with-dependency"/>
</sample>
++++

These limitations make it preferable to use the `Copy` task wherever possible, because of its builtin support for incremental building and task dependency inference. That is why the `copy()` method is intended for use by <<custom_tasks,custom tasks>> that need to copy files as part of their function. Custom tasks that use the `copy()` method should declare the necessary inputs and outputs relevant to the copy action.

[[sec:sync_task]]
==== Mirroring directories and file collections with the `Sync` task

The api:org.gradle.api.tasks.Sync[] task, which extends the `Copy` task, copies the source files into the destination directory and then removes any files from the destination directory which it did not copy. In other words, it synchronizes the contents of a directory with its source. This can be useful for doing things such as installing your application, creating an exploded copy of your archives, or maintaining a copy of the project's dependencies.

Here is an example which maintains a copy of the project's runtime dependencies in the `build/libs` directory.

++++
<sample id="syncDependencies" dir="userguide/files/sync" title="Using the Sync task to copy dependencies">
    <sourcefile file="build.gradle" snippet="copy-dependencies"/>
    <test args="libs"/>
</sample>
++++

[[sec:archives]]
=== Archive creation in depth

Archives are essentially self-contained file systems and Gradle treats them as such. This is why working with archives is very similar to working with files and directories, including such things as file permissions.

Out of the box, Gradle supports creation of both ZIP and TAR archives, and by extension Java's JAR, WAR and EAR formats, which are essentially ZIPs. Each of these formats has a corresponding task type to create them: api:org.gradle.api.tasks.bundling.Zip[], api:org.gradle.api.tasks.bundling.Tar[], api:org.gradle.api.tasks.bundling.Jar[], api:org.gradle.api.tasks.bundling.War[], and api:org.gradle.plugins.ear.Ear[]. These all work the same way and are based on copy specifications, just like the `Copy` task.

Creating an archive file is essentially a file copy, where the destination is implicit (the archive file itself). Here's an example:

++++
<sample id="createZip" dir="userguide/files/archives" title="Creating a ZIP archive">
    <sourcefile file="build.gradle" snippet="zip"/>
</sample>
++++

TODO: Use a generic archive example. No need to use Java here.

[TIP]
.Why are you using the Java plugin?
====
The Java plugin adds a number of default values for the archive tasks. You can use the archive tasks without using the Java plugin, if you like. You will need to provide values for some additional properties.
====

The full power of copy specifications are available to you when creating archives, which means you can do content filtering, file renaming or anything else that is covered in the previous section. A particularly common requirement is to copy files into specific subdirectories in the archive, which can be achieved with `into()` <<Using child specifications,child specifications>>.

Gradle does of course allow you create as many archive tasks as you want, but it's worth bearing in mind that many convention-based plugins provide their own. For example, the Java plugin adds a `jar` task for packaging a project's compiled classes in a JAR. Many of these plugins provide sensible conventions for the names of archives as well as the copy specifications used. We recommend you use these tasks wherever you can, rather than overriding them with your own.

[[sec:archive_naming]]
==== Archive naming

Gradle has several conventions around the naming of archives and where they are created based on the plugins your project uses. The main convention is provided by the `base` plugin, which defaults to creating archives in the `$buildDir/distributions` directory and typically uses archive names of the form _[projectName]-[version].[type]_. The following example comes from a project named 'zipProject', hence the `myZip` task creates an archive named 'zipProject-1.0.zip':

++++
<sample id="archiveNaming" dir="userguide/files/archiveNaming" title="Creation of ZIP archive">
    <sourcefile file="build.gradle"/>
    <output args="-q myZip"/>
</sample>
++++

Note that the name of the archive does _not_ derive from the name of the task that creates it.

If you want to change the name and location of a generated archive file, you can provide values for the `archiveName` and `destinationDir` properties of the corresponding task. These override any conventions that would otherwise apply.

Alternatively, you can make use of the default archive name pattern provided by api:org.gradle.api.tasks.bundling.AbstractArchiveTask#getArchiveName[]: _[baseName]-[appendix]-[version]-[classifier].[extension]_. You can set each of these properties on the task separately if you wish. Note that the `base` plugin uses the convention of project name for _baseName_, project version for _version_ and the archive type for _extension_. It does not provide values for the other properties.

This example configures just the `baseName` property, overriding the default of the project name:

++++
<sample id="zipWithCustomName" dir="userguide/tutorial/zipWithCustomName" title="Configuration of archive task - custom archive name">
    <sourcefile file="build.gradle"/>
    <output args="-q myZip"/>
</sample>
++++

You can also override the default `baseName` value for _all_ the archive tasks in your build by using the _project_ property `archivesBaseName`, as demonstrated by the following example:

++++
<sample id="zipWithArguments" dir="userguide/tutorial/zipWithArguments" title="Configuration of archive task - appendix &amp; classifier">
    <sourcefile file="build.gradle"/>
    <output args="-q myZip"/>
</sample>
++++

You can find all the possible archive task properties in the API documentation for api:org.gradle.api.tasks.bundling.AbstractArchiveTask[], but we have also summarized the main ones in <<archiveTasksNamingProperties>> below.

[[archiveTasksNamingProperties]]
.Archive tasks - naming properties
[cols="a,a,a,a", options="header"]
|===
| Property name
| Type
| Default value
| Description

| `archiveName`
| `String`
| `__baseName__-__appendix__-__version__-__classifier__.__extension__`

If any of these properties is empty the trailing `-` is not added to the name.
| The base file name of the generated archive

| `archivePath`
| `File`
| `__destinationDir__/__archiveName__`
| (_read-only_) The absolute path of the generated archive.

| `destinationDir`
| `File`
| Depends on the archive type. JARs and WARs go into `__project.buildDir__/libraries`. ZIPs and TARs go into `__project.buildDir__/distributions`.
| The directory to generate the archive into

| `baseName`
| `String`
| `__project.name__`
| The base name portion of the archive file name.

| `appendix`
| `String`
| `null`
| The appendix portion of the archive file name.

| `version`
| `String`
| `__project.version__`
| The version portion of the archive file name.

| `classifier`
| `String`
| `null`
| The classifier portion of the archive file name,

| `extension`
| `String`
| Depends on the archive type, and for TAR files, the compression type as well: `zip`, `jar`, `war`, `tar`, `tgz` or `tbz2`.
| The extension of the archive file name.
|===

[[sec:sharing_content_between_multiple_archives]]
==== Sharing content between multiple archives

<<Sharing copy specs,As described earlier>>, you can use the api:org.gradle.api.Project#copySpec(org.gradle.api.Action)[] method to share content between archives.

[[sec:reproducible_archives]]
==== Reproducible archives

Sometimes it's desirable to recreate archives exactly the same, byte for byte, on different machines. You want to be sure that building an artifact from source code produces the same result no matter when and where it is built. This is necessary for projects like https://reproducible-builds.org/[reproducible-builds.org].

Reproducing the same byte-for-byte archive poses some challenges since the order of the files in an archive is influenced by the underlying file system. Each time a ZIP, TAR, JAR, WAR or EAR is built from source, the order of the files inside the archive may change. Files that only have a different timestamp also causes differences in archives from build to build. All api:org.gradle.api.tasks.bundling.AbstractArchiveTask[] (e.g. Jar, Zip) tasks shipped with Gradle include <<feature_lifecycle,incubating>> support producing reproducible archives.

For example, to make a `Zip` task reproducible you need to set api:org.gradle.api.tasks.bundling.Zip#isReproducibleFileOrder()[] to `true` and api:org.gradle.api.tasks.bundling.Zip#isPreserveFileTimestamps()[] to `false`. In order to make all archive tasks in your build reproducible, consider adding the following configuration to your build file:

++++
<sample id="createZip" dir="userguide/files/archives" title="Activating reproducible archives">
    <sourcefile file="build.gradle" snippet="reproducible"/>
</sample>
++++

Often you will want to publish an archive, so that it is usable from another project. This process is described in <<artifact_management>>

[[sec:properties_files]]
=== Java properties files

Properties files are used in many places during Java development. Gradle makes it easy to create properties files as a normal part of the build. You can use the api:org.gradle.api.tasks.WriteProperties[] task to create properties files.

The `WriteProperties` task also fixes a well-known problem with `Properties.store()` that can reduce the usefulness of incremental builds (see <<sec:up_to_date_checks>>). The standard Java way to write a properties file produces a unique file every time, even when the same properties and values are used, because it includes a timestamp in the comments. Gradle's `WriteProperties` task generates exactly the same output byte-for-byte if none of the properties have changed. This is achieved by a few tweaks to how a properties file is generated:

* no timestamp comment is added to the output
* the line separator is system independent, but can be configured explicitly (it defaults to `'\n'`)
* the properties are sorted alphabetically
