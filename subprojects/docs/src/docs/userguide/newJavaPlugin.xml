<!--
  ~ Copyright 2015 the original author or authors.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<chapter id='new_java_plugin'>
    <title>The New Java Plugin</title>

    <para>The New Java plugin is an incubating plugin intended to replace the <link linkend="java_plugin">Java plugin</link>, and
        leveraging the <link linkend="new_model">new model infrastructure</link>
        to acheive best performance, improved expressiveness
        and variant-aware dependency management.
    </para>

    <section>
        <title>The Software Model</title>
        <para>The plugin relies on the software model, which allows describing how an application is built, and how components
            of a model come together. The software model is organized around key concepts:
        </para>
        <para>
            <itemizedlist>
                <listitem>A
                    <firstterm>component</firstterm>
                    is a general concept for a piece of software, that might be deliverable. Examples of components are an standalone
                    application, a web application, a library, ... A component is often composed of other components.
                </listitem>
                <listitem>A
                    <firstterm>library</firstterm>
                    is a component which is buildable as a unit. In the Java world, a library is often assimilated to a Jar file, but while a Jar file
                    represents an output, a library is the description of how the output is built. A library is defined by the combination of its source sets and variants.
                </listitem>
                <listitem>A
                    <firstterm>source set</firstterm>
                    represents a logical group of sources for component. As such, a source set is often an input to a single
                    compilation task, which will produce an output (classes, compiled CSS, ...). A library may consist of multiple <firstterm>source sets</firstterm>.
                </listitem>
                <listitem>A
                    <firstterm>variant</firstterm>
                    represents a modulation of a component. A library, for example, might target Java 6 and Java 7, effectively producing two
                    distinct outputs: a Java 6 jar and a Java 7 jar. In this case, the target platform is an example of a <firstterm>variant dimension</firstterm>.
                    Custom library types may define their own <firstterm>variant dimensions</firstterm>, which will participate in dependency resolution.
                </listitem>
                <listitem>A <firstterm>binary</firstterm>
                    represents the output of a library. Given a combination of variants, a library may produce multiple binaries. A binary is often
                    a consumable artifact of other components.
                </listitem>
            </itemizedlist>
        </para>
    </section>

    <section>
        <title>Usage</title>
        <para>To use the new Java plugin, include the following in your build script:</para>
        <sample id="newJavaQuickstart" dir="newJavaPlugin/quickstart" title="Using the new Java plugin">
            <sourcefile file="build.gradle" snippet="use-plugin"/>
        </sample>
    </section>

    <section>
        <title>Creating a library</title>
        <para>A library is created by declaring a <firstterm>JvmLibrarySpec</firstterm> under the <literal>components</literal>
            element of the <literal>model</literal>:
        </para>
        <sample id="newJavaQuickstart" dir="newJavaPlugin/quickstart" title="Creating a source set">
            <sourcefile file="build.gradle" snippet="single-lib"/>
            <output args='build' ignoreExtraLines="true"/>
        </sample>
        <para>This example creates a library named <literal>main</literal>, which will implicitly create a <firstterm>source set</firstterm>
            named <literal>java</literal>.
            Therefore the new Java plugin follows the conventions of the <link linkend="java_plugin">old Java plugin</link>, and Java sources
            are expected to be found in <filename>src/main/java</filename>,
            while resources are expected to be found in <filename>src/main/resources</filename>.
        </para>
        <para>It is possible to configure an existing <firstterm>source set</firstterm>
            through the <literal>sources</literal> container:
        </para>
        <sample id="newJavaQuickstart" dir="newJavaPlugin/quickstart" title="Configuring a source set">
            <sourcefile file="build.gradle" snippet="configure-sourceset"/>
        </sample>
        <para>It is also possible to create an additional source set, using the
            <literal>JavaSourceSet</literal>
            type:
        </para>
        <sample id="newJavaQuickstart" dir="newJavaPlugin/quickstart" title="Creating a new source set">
            <sourcefile file="build.gradle" snippet="new-sourceset"/>
        </sample>
    </section>

    <section>
        <title>Dependencies between components</title>
        <para>The new Java plugin supports API dependencies between components. Having an API dependency means that if
            <literal>A</literal> depends on <literal>B</literal>, then the API of <literal>B</literal>
            is required to compile <literal>A</literal>. Gradle will then
            make sure that the dependency is built before the dependent component, and that the dependency
            appears on <firstterm>compile classpath</firstterm>.
            API dependencies are not transitive, and there's no runtime dependencies management solution yet.
        </para>
        <para>Currently the plugin supports two kinds of dependencies:
            <itemizedlist>
                <listitem>dependencies onto a local project</listitem>
                <listitem>dependencies onto a local library</listitem>
            </itemizedlist>
            Dependencies onto external components are not yet supported.
        </para>
        <para>Dependencies are declared on a <firstterm>source set</firstterm>:</para>
        <sample id="newJavaMultiComponents" dir="newJavaPlugin/multiplecomponents" title="Declaring a dependency onto a library">
            <sourcefile file="build.gradle" snippet="simple-dependency"/>
            <output args="serverJar" outputFile="newJavaMultiComponents-serverJar.out" ignoreExtraLines="true"/>
        </sample>
        <para>This example declares an API dependency for the <literal>java</literal> source set of the <literal>server</literal> library
        onto the <literal>core</literal> library of the same project. However, it is possible for a library to be defined in a different
        project:</para>
        <sample id="newJavaMultiComponents" dir="newJavaPlugin/multiplecomponents" title="Declaring a dependency onto a project with an explicit library">
            <sourcefile file="build.gradle" snippet="dependency-other-project"/>
            <output args="clientJar" outputFile="newJavaMultiComponents-clientJar.out" ignoreExtraLines="true"/>
        </sample>
        <para>When the target project only defines a single library, it is possible to omit the <literal>library</literal> selector
        altogether:</para>
        <sample id="newJavaMultiComponents" dir="newJavaPlugin/multiplecomponents" title="Declaring a dependency onto a project with an implicit library">
            <sourcefile file="build.gradle" snippet="dependency-other-project-implicit-lib"/>
        </sample>
    </section>

</chapter>
