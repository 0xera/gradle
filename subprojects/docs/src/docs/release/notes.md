## New and noteworthy

Here are the new features introduced in this Gradle release.

### Easier debugging of TestKit functional tests

The [Gradle TestKit](userguide/test_kit.html) facilitates programmatic execution of Gradle builds for the purpose of testing plugins and build logic.
This release of Gradle makes it easier to use a debugger to debug build logic under test.

In order to provide an accurate simulation of a Gradle build, the TestKit executes the build in a _separate process_ by default.
This avoids interference to the build environment by the test environment and vice versa.
This does mean however, that executing a test via a debugger does not automatically allow debugging the build process.

To support debugging, it is now possible to specify that the build should be run in the same process as the test.
This can be done by setting the `org.gradle.testkit.debug` system property to `true` for the test process,
or by using the [`withDebug(boolean)`](javadoc/org/gradle/testkit/runner/GradleRunner.html#withDebug\(boolean\))
method of the `GradleRunner`.

Please see the [Gradle User Guide section on debugging with the TestKit](userguide/test_kit.html#test-kit-debug) for more information.

### Cross version testing with the Gradle TestKit

It is now possible to use the [`GradleRunner`](javadoc/org/gradle/testkit/runner/GradleRunner.html) to execute builds with arbitrary Gradle versions and distributions.
This feature is extremely useful for verifying a plugin's functionality with a range of different Gradle versions.

The version to use can be specified via the new [`GradleRunner.withGradleVersion(String)`](javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleVersion\(java.lang.String\)) method.

Please see the [section in the User Guide on specifying versions](userguide/test_kit.html#gradle-runner-gradle-version) for more information.

### Capturing build output when using the Gradle TestKit

When using the [`GradleRunner`](javadoc/org/gradle/testkit/runner/GradleRunner.html) to programmatically execute Gradle builds for testing plugins and build logic,
it is now possible to capture the output from the build under test.

By default, no output is captured.
The new [`forwardOutput()`](javadoc/org/gradle/testkit/runner/GradleRunner.html#forwardOutput\(\))
method can be used to route the output from the build under test to the output stream of the process using the Gradle runner.
This is often convenient when being used in a testing context, as output generated by the test is typically associated with the test results (e.g. in the IDE UI or test results report).

If more control is needed, the new [`forwardStdOut(Writer)`](javadoc/org/gradle/testkit/runner/GradleRunner.html#forwardStdOut\(java.io.Writer\)) and
[`forwardStdErr(Writer)`](javadoc/org/gradle/testkit/runner/GradleRunner.html#forwardStdErr\(java.io.Writer\)) methods can be used.

### Model rules improvements

#### Declaring packages that belong to an API

It is now possible to declare the packages that make up the API of a JVM component. Declaring the API of a component is done using the `api { ... }` block:

    model {
        components {
            main(JvmLibrarySpec) {
                api {
                    // declares the package 'com.acme' as belonging to the public, exported API
                    exports 'com.acme'
                }
            }
        }
    }

Gradle will automatically create an API jar for the main component. Components that depend on that main component will compile against that API jar.
The API jar will only include classes that belong to those packages. As a consequence:
   - trying to compile a consumer that accesses a class which which doesn't belong to the list of exported packages will result in a compile time error.
   - updating a non-API class will not result in the compilation of downstream consumers.

#### `$.p` expressions in DSL rules

TBD: DSL now supports `$.p` expressions in DSL rules:

    model {
        components {
            all {
                targetPlatform = $.platforms.java6
            }
        }
        components {
            def plat = $.platforms
            all {
                targetPlatform = plat.java6
            }
        }
    }

TBD: DSL now supports `$('p')` expressions in DSL rules:

    model {
        components {
            all {
                targetPlatform = $('platforms.java6')
            }
        }
    }

#### Consistent validation of model types
 The error messages produced when a model type is not supported has been improved to describe the types that are actually supported. In the following example `MyModel` is not a valid managed
  model type because managed models cannot have properties of type `java.io.FileInputStream `.

    @Managed
        interface MyModel {
        FileInputStream getStream()
        void setStream(FileInputStream stream)
    }


    A model element of type: 'MyModel' can not be constructed.
    Its property 'java.io.FileInputStream stream' can not be constructed
    It must be one of:
      - A managed type (annotated with @Managed)
      - A managed collection. A valid managed collection takes the form of ModelSet<T> or ModelMap<T> where 'T' is:
          - A managed type (annotated with @Managed)
      - A scalar collection. A valid scalar collection takes the form of List<T> or Set<T> where 'T' is one of (String, Boolean, Character, Byte, Short, Integer, Float, Long, Double, BigInteger, BigDecimal, File)
      - An unmanaged property (i.e. annotated with @Unmanaged)

#### Adding `LanguageSourceSet`'s to `FunctionalSourceSet`'s

It is now possible to add `LanguageSourceSet`'s, of any type known type (see <a href="javadoc/org/gradle/platform/base/LanguageType.html">`org.gradle.platform.base.LanguageType`</a>),
to `FunctionalSourceSet`'s which exist in the model space.

    class Rules extends RuleSource {
        @Model
        void functionalSources(FunctionalSourceSet fss) {
            fss.create("myJavaSourceSet", JavaSourceSet) { LanguageSourceSet lss ->
                lss.source.srcDir "src/main/myJavaSourceSet"
            }
        }
    }
    apply plugin: Rules

Or via the model DSL

    model {
        functionalSources(FunctionalSourceSet){
            myJavaSourceSet(JavaSourceSet) {
                source {
                    srcDir "src/main/myJavaSourceSet"
                }
            }
        }
    }

Any registered `LanguageSourceSet` implementations can be used to create LanguageSourceSet's. `LanguageSourceSet`'s are typically registered as follows:

    class JavaLangRuleSource extends RuleSource {
        @LanguageType
        void registerLanguage(LanguageTypeBuilder<JavaSourceSet> builder) {
            builder.setLanguageName("java");
            builder.defaultImplementation(DefaultJavaLanguageSourceSet.class);
        }

    }
    apply plugin: JavaLangRuleSource

Note: `LanguageSourceSet`'s added in this fashion are not added to the projects `ProjectSourceSet`

### Support for API dependencies in the 'jvm-components' plugin

The API of a JVM library consists of the API classes of the library, plus the API of dependent libraries that are defined as
"exported" in the dependency specification.

TODO: Expand this and provide a DSL example.

### Tooling API improvements

#### Expose Eclipse builders and natures

Clients of the Tooling API now can query the list of Eclipse builders and natures via the
<a href="javadoc/org/gradle/tooling/model/eclipse/EclipseProject.html">EclipseProject</a> model. The result of the `EclipseProject.getProjectNatures()`
and `EclipseProject.getBuildCommands()` contain the builders and natures required for the target project as well as the customisation defined the
'eclipse' <a href="dsl/org.gradle.plugins.ide.eclipse.model.EclipseProject.html">Gradle plugin configuration</a>.

### Faster up-to-date checking for incremental builds

Gradle now uses a more efficient mechanism to scan the filesystem, which makes up-to-date checks significantly faster. 
This improvement is only available when running Gradle with Java 7 or newer. Windows users should use Java 8 for best results.

Other improvements have been made to speed-up include and exclude pattern evaluation. No changes are necessary to take advantage of this and this optimization should improve build times for Java 6 and newer.

Very large builds (many thousands of source files) could see incremental build speeds up to 80% faster than 2.7 and up to 40% better than 2.8. 

#### Reduced memory footprint for incremental builds

Gradle 2.9 uses much less memory than previous releases when performing incremental builds. Some builds use 30-70% less memory. 

## Promoted features

Promoted features are features that were incubating in previous versions of Gradle but are now supported and subject to backwards compatibility.
See the User guide section on the “[Feature Lifecycle](userguide/feature_lifecycle.html)” for more information.

The following are the features that have been promoted in this Gradle release.

<!--
### Example promoted
-->

## Fixed issues

## Deprecations

Features that have become superseded or irrelevant due to the natural evolution of Gradle become *deprecated*, and scheduled to be removed
in the next major Gradle version (Gradle 3.0). See the User guide section on the “[Feature Lifecycle](userguide/feature_lifecycle.html)” for more information.

The following are the newly deprecated items in this Gradle release. If you have concerns about a deprecation, please raise it via the [Gradle Forums](http://discuss.gradle.org).

<!--
### Example deprecation
-->

## Potential breaking changes

### Changes to native software model

TBD general warning about breaking changes, e.g. replacing `NativeExecutableBinarySpec#setExecutableFile` with `#getExecutable.setFile()`

Previously, the `PreprocessingTool` use to supply compiler arguments and defines to a `NativeBinarySpec` was available via the Gradle extension mechanism.
These tools accessors are now implemented directly by `NativeBinarySpec`, which no longer implements `ExtensionAware`. No changes to build scripts should be required.

### Changes to experimental integration between software model and Java plugins

TBD

- `binaries` container is now only visible to rules via model. The `binaries` project extension has been removed.

### Changes to experimental model rules DSL

TBD

- The `model { }` block can now contain only rule blocks.

### Changes to up-to-date checking

TBD

- up-to-date checking of zipTree/tarTree inputs has changed. The up-to-date checking will only check the backing archive file.
  - Previously the content of the archive file was extracted to a temporary directory in the up-to-date checking phase and the actual files were added to the input snapshot.
  - There is a change in behaviour for builds that contain a zipTree/tarTree with a filter. Previously only changes to files inside the archive matching the filter would make the input out-of-date.

- previously up-to-date checking didn't consider changes in directories. Directories are now also added to input and output snapshots in up-to-date checking.

## External contributions

We would like to thank the following community members for making contributions to this release of Gradle.

<!--
* [Some person](https://github.com/some-person) - fixed some issue (GRADLE-1234)
-->

We love getting contributions from the Gradle community. For information on contributing, please see [gradle.org/contribute](http://gradle.org/contribute).

## Known issues

Known issues are problems that were discovered post release that are directly related to changes made in this release.
