/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import data.Trie
import data.trieFrom
import elmish.elementById
import elmish.mountComponentAt
import elmish.tree.Tree
import elmish.tree.TreeView


fun main() {
    mountComponentAt(
        elementById("app"),
        HomePage,
        homePageModelFromJsModel(instantExecutionFailures)
    )
}


/**
 * External model defined in `instant-execution-failures.js`, a file generated by `InstantExecutionReport`.
 */
private
external val instantExecutionFailures: JsModel


private
typealias JsModel = Array<JsFailure>


private
external interface JsFailure {
    val trace: Array<JsTrace>
    val message: String
    val error: String?
}


private
external interface JsTrace {
    val kind: String
}


private
external interface JsTraceTask : JsTrace {
    val path: String
    val type: String
}


private
external interface JsTraceBean : JsTrace {
    val type: String
}


private
external interface JsTraceField : JsTrace {
    val name: String
    val declaringType: String
}


private
external interface JsTraceProperty : JsTrace {
    val name: String
    val task: String
}


private
data class ImportedFailure(
    val failure: JsFailure,
    val trace: List<FailureNode>
)


private
fun homePageModelFromJsModel(jsFailures: JsModel): HomePage.Model {
    val failures = jsFailures.map {
        ImportedFailure(it, it.trace.map(::toFailureNode))
    }
    return HomePage.Model(
        totalFailures = instantExecutionFailures.size,
        messageTree = treeModelFor(
            FailureNode.Label("Failures grouped by message"),
            failureNodesByMessage(failures)
        ),
        taskTree = treeModelFor(
            FailureNode.Label("Failures grouped by task"),
            failureNodesByTask(failures)
        )
    )
}


private
fun failureNodesByTask(failures: List<ImportedFailure>): Sequence<List<FailureNode>> =
    failures.asSequence().map { failure ->
        failure.trace.asReversed().mapIndexed { index, node ->
            when (index) {
                0 -> errorOrWarningNodeFor(failure.failure, node)
                else -> node
            }
        } + failureNodeFor(failure.failure)
    }


private
fun failureNodesByMessage(failures: List<ImportedFailure>): Sequence<MutableList<FailureNode>> =
    failures.asSequence().map {
        mutableListOf<FailureNode>().apply {
            add(errorOrWarningNodeFor(it.failure, FailureNode.Label(it.failure.message)))
            it.trace.forEach { part ->
                add(part)
            }
            exceptionNodeFor(it.failure)?.let {
                add(it)
            }
        }
    }


private
fun toFailureNode(trace: JsTrace): FailureNode = when (val kind = trace.kind) {
    "Task" -> trace.unsafeCast<JsTraceTask>().run {
        FailureNode.Task(path, type)
    }
    "Bean" -> trace.unsafeCast<JsTraceBean>().run {
        FailureNode.Bean(type)
    }
    "Field" -> trace.unsafeCast<JsTraceField>().run {
        FailureNode.Property("field", name, declaringType)
    }
    "InputProperty" -> trace.unsafeCast<JsTraceProperty>().run {
        FailureNode.Property("input property", name, task)
    }
    "OutputProperty" -> trace.unsafeCast<JsTraceProperty>().run {
        FailureNode.Property("output property", name, task)
    }
    else -> FailureNode.Label(kind)
}


private
fun errorOrWarningNodeFor(failure: JsFailure, label: FailureNode): FailureNode =
    failure.error?.let {
        FailureNode.Error(label)
    } ?: FailureNode.Warning(label)


private
fun failureNodeFor(it: JsFailure) =
    exceptionNodeFor(it) ?: FailureNode.Label(it.message)


private
fun exceptionNodeFor(it: JsFailure): FailureNode? =
    it.error?.let {
        val stackTraceLines = it.lineSequence()
        FailureNode.Exception(
            stackTraceLines.first(),
            stackTraceLines.drop(1).map(String::trim).joinToString("\n")
        )
    }


private
fun <T> treeModelFor(
    label: T,
    sequence: Sequence<List<T>>
): TreeView.Model<T> = TreeView.Model(
    treeFromTrie(
        label,
        trieFrom(sequence)
    )
)


private
fun <T> treeFromTrie(label: T, trie: Trie<T>): Tree<T> =
    Tree(label, subTreesFromTrie(trie))


private
fun <T> subTreesFromTrie(trie: Trie<T>): List<Tree<T>> =
    trie.asSequence().sortedBy { it.key.toString() /* TODO: */ }.map {
        @Suppress("unchecked_cast")
        treeFromTrie(
            it.key,
            it.value as Trie<T>
        )
    }.toList()
