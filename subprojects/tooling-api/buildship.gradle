/**
 * This script generates an Eclipse plug-in project from a local Tooling API build
 * which can be used consumed by Buildship at development-time.
 *
 * To generate the Eclipse project, execute the 'buildshipEclipseProject' task. The task
 * takes the output of the 'jarjarJar' task, analyzes its content, and assembles an Eclipse plug-in
 * project in the $buildDir/buildshipProject folder.
 *
 * The $buildDir/buildshipProject folder can be imported into Eclipse by using the
 * File > Import > Existing Project into workspace... functionality.
 *
 * If the Buildship plug-ins are present in the same workspace, then the binary Tooling API
 * dependency is automatically replaced with the imported project.
 */
import java.util.regex.Matcher
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

task buildshipEclipseProject(type: CreateBuildshipEclipseProjectTask) {
    description = "Creates an Eclipse plug-in project from the Tooling API fat jar"
    dependsOn jarjarJar

    jarFile = jarjarJar.outputs.files[0]
    projectDirectory = file("$buildDir/buildshipProject")
}

class CreateBuildshipEclipseProjectTask extends DefaultTask {

    @Input
    File jarFile

    @OutputDirectory
    File projectDirectory

    @TaskAction
    void generateBuildshipProject() {
        // delete artifacts from previous executions
        if (projectDirectory.exists()) {
            def success = projectDirectory.deleteDir()
            if (!success) {
                throw new RuntimeException("Unable to deleted directory ${projectDirectory.absolutePath}")
            }
        }

        // create manifest and place it in the META-INF folder
        def manifestFile = new File(projectDirectory, "META-INF/MANIFEST.MF")
        def success = manifestFile.parentFile.mkdirs()
        if (!success) {
            throw new RuntimeException("Unable to create directory ${manifestFile.parentFile.absolutePath}")
        }
        manifestFile.text = calculateManifest(project.version, jarFile)

        // copy the jar to the project location
        project.copy {
            from jarFile
            into projectDirectory
        }

        // create the .project and .classpath files
        new File(projectDirectory, '.project').text = getDotProjectText()
        new File(projectDirectory, '.classpath').text = getDotClasspathText(jarFile.name)
    }

    String calculateManifest(String projectVersion, File jar) {
        def bundleVersion = getBundleVersion(projectVersion)
        def qualifier = new Date().format('yyyyMMddkkmm')
        def packageNames = getPackageNames(jar)
        def packageExports = getPackageExports(packageNames, bundleVersion)
     """Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: Gradle Tooling API
Bundle-Vendor: Gradle Inc.
Bundle-SymbolicName: org.gradle.toolingapi
Bundle-Version: ${bundleVersion}.v${qualifier}
Bundle-ClassPath: .
Bundle-RequiredExecutionEnvironment: JavaSE-1.6
Export-Package: ${packageExports}
Require-Bundle: org.slf4j.api;bundle-version="1.7.2"
"""
}

    String getBundleVersion(String projectVersion) {
        Matcher matcher = projectVersion =~ /(\d+).(\d+)(?:-.*|\.(\d+)(?:-.*)?)?/
        if (matcher.matches()) {
            def major = matcher.group(1)
            def minor = matcher.group(2)
            def service = matcher.group(3)
            if (service == null) service = "0"
            return "${major}.${minor}.${service}"
        } else {
            throw new IllegalArgumentException("Invalid project version format: $projectVersion")
        }
    }

    Set<String> getPackageNames(File jar) {
        def result = [] as Set
        new ZipInputStream(new FileInputStream(jar)).withCloseable { zip ->
            ZipEntry e
            while (e = zip.nextEntry) {
                if (!e.directory && e.name.endsWith(".class")) {
                    int index = e.name.lastIndexOf('/')
                    if (index < 0) index = e.name.length()
                    String packageName = e.name.substring(0, index).replace('/', '.')
                    result.add(packageName)
                }
            }
        }
        result
    }

    String getPackageExports(Set<String> packageNames, String bundleVersion) {
        // the Tooling API has more than two packages
        StringBuilder exportedPackages = new StringBuilder("${packageNames[0]};version=\"${bundleVersion}\"")
        for (i in 1..< packageNames.size()) {
            exportedPackages.append ",\n ${packageNames[i]};version=\"${bundleVersion}\""
        }
        exportedPackages.toString()
    }

    String getDotProjectText() {
        """<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
  <name>org.gradle.toolingapi</name><comment/><projects/>
  <buildSpec>
    <buildCommand><name>org.eclipse.jdt.core.javabuilder</name><arguments/></buildCommand>
    <buildCommand><name>org.eclipse.pde.ManifestBuilder</name><arguments/></buildCommand>
    <buildCommand><name>org.eclipse.pde.SchemaBuilder</name><arguments/></buildCommand>
  </buildSpec>
  <natures>
    <nature>org.eclipse.pde.PluginNature</nature>
    <nature>org.eclipse.jdt.core.javanature</nature>
  </natures>
</projectDescription>
"""
    }

    String getDotClasspathText(String jarName) {
        """<?xml version="1.0" encoding="UTF-8"?>
<classpath>
  <classpathentry exported="true" kind="lib" path="${jarName}"/>
  <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
  <classpathentry kind="output" path="bin"/>
</classpath>
"""
    }


}
