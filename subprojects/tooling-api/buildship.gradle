/**
 * Script to generate an Eclipse project from a locally-built Tooling API fat jar
 * which can be used directly for Buildship development.
 */
import java.util.regex.Matcher
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

task buildshipProject() {
    dependsOn jar, jarjarJar

    def dotProject = file('src/main/resources/buildship/.classpath')
    def dotClasspath = file('src/main/resources/buildship/.project')
    inputs.file dotProject
    inputs.file dotClasspath

    def location = file("$buildDir/buildshipProject")
    outputs.dir location

    doLast {
        def jar = tasks['jarjarJar'].outputs.files[0]

        // create manifest and copy it to the META-INF folder
        def manifestFile = new File(location, "META-INF/MANIFEST.MF")
        manifestFile.parentFile.mkdirs()
        manifestFile.text = calculateManifest(version, jar)

        // copy the Eclipse project descriptors and the jar
        copy {
            from files(dotProject, dotClasspath, jar)
            into location
            // the .classpath file has a reference to the 'toolingapi.jar' file
            rename 'gradle-tooling-api.*', 'toolingapi.jar'
        }
    }
}

def calculateManifest(String projectVersion, File jar) {
    def bundleVersion = getBundleVersion(projectVersion)
    def qualifier = new Date().format('yyyyMMddkkmm')
    def packageNames = getPackageNames(jar)
    def packageExports = getPackageExports(packageNames, bundleVersion)
    return """Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: Gradle Tooling API
Bundle-Vendor: Gradle Inc.
Bundle-SymbolicName: org.gradle.toolingapi
Bundle-Version: ${bundleVersion}.v${qualifier}
Bundle-ClassPath: .
Bundle-RequiredExecutionEnvironment: JavaSE-1.6
Export-Package: ${packageExports}
Require-Bundle: org.slf4j.api;bundle-version="1.7.2"
"""
}

def getBundleVersion(String projectVersion) {
    Matcher matcher = version =~ /(\d+).(\d+)(?:-.*|\.(\d+)(?:-.*)?)?/
    if (matcher.matches()) {
        def major = matcher.group(1)
        def minor = matcher.group(2)
        def service = matcher.group(3)
        if (service == null) service = "0"
        return "${major}.${minor}.${service}"
    } else {
        return "NIL"
    }
}

def getPackageNames(File jar) {
    def jarStream = new FileInputStream(jar)
    ZipInputStream zip = new ZipInputStream(new FileInputStream(jar))
    def result = [] as Set
    while(true) {
        ZipEntry e = zip.nextEntry
        if (e == null) break
        if (!e.directory && e.name.endsWith(".class")) {
            int index = e.name.lastIndexOf('/')
            if (index < 0) index = e.name.length()
            String packageName = e.name.substring(0, index).replace('/', '.')
            result.add(packageName)
        }
    }
    jarStream.close()
    result
}

def getPackageExports(packageNames, bundleVersion) {
    // the Tooling API has more than two packages
    StringBuilder exportedPackages = new StringBuilder("${packageNames[0]};version=\"${bundleVersion}\"")
    for (i in 1..< packageNames.size()) {
        exportedPackages.append ",\n ${packageNames[i]};version=\"${bundleVersion}\""
    }
    exportedPackages.toString()
}
